<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script>
        window.createLucideIcons = () => {
            if (window.lucide && window.lucide.createIcons) {
                window.lucide.createIcons();
            }
        };
    </script>
    
    <meta name="theme-color" content="#4f46e5">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>📚</text></svg>">
    
   <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
        }
        
        .glass-base {
            backdrop-filter: blur(16px);
            border: 1px solid rgba(126, 87, 87, 0.1);
            transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        
        .glass-base:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.15), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
        }

        .subject-radio:checked + label {
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%);
            border-color: #a5b4fc;
            color: #fff;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.6);
            transform: scale(1.05);
        }
        
        .subject-radio + label {
            transition: all 0.2s ease;
        }
        
        input[type="checkbox"] {
            appearance: none;
            height: 1.25rem;
            width: 1.25rem;
            border: 2px solid #6b7280;
            border-radius: 0.25rem;
            background-color: transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="checkbox"]:checked {
            background-color: #4f46e5;
            border-color: #4f46e5;
        }
        
        input[type="checkbox"]:checked::after {
            content: '✓';
            display: block;
            color: white;
            font-size: 0.75rem;
            text-align: center;
            line-height: 1.1;
        }
        
        body.modal-open {
            overflow: hidden;
        }
        
        .empty-state {
            padding: 3rem 1rem;
            text-align: center;
        }
        
        .empty-state-icon {
            font-size: 4rem;
            opacity: 0.3;
            margin-bottom: 1rem;
        }
        
        .achievement-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
        
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
            z-index: 100;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .priority-high { border-left: 4px solid #ef4444; }
        .priority-medium { border-left: 4px solid #f59e0b; }
        .priority-low { border-left: 4px solid #10b981; }
        
        @media (max-width: 768px) {
            #fullscreen-time-display { font-size: 8rem; }
        }
        @media (max-width: 480px) {
            #fullscreen-time-display { font-size: 6rem; }
        }
    </style>
</head>
<body class="text-white min-h-screen">
    <div class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-6 sm:mb-8">
            <h1 class="text-3xl font-extrabold text-indigo-400">Study Tracker Pro</h1>
            <p class="text-gray-400 text-sm mt-2">Your productivity companion</p>
        </header>

        <nav class="flex space-x-2 mb-6 p-1 bg-gray-800 rounded-full overflow-x-auto">
            <button id="nav-timer-btn" onclick="switchPage('timer')" class="flex-1 py-2 px-3 sm:px-4 rounded-full text-xs sm:text-sm font-semibold transition-colors whitespace-nowrap bg-indigo-600">
                <i data-lucide="clock" class="w-4 h-4 inline mr-1"></i> Timer
            </button>
            <button id="nav-tasks-btn" onclick="switchPage('tasks')" class="flex-1 py-2 px-3 sm:px-4 rounded-full text-xs sm:text-sm font-semibold transition-colors whitespace-nowrap bg-gray-700/50 hover:bg-gray-700">
                <i data-lucide="list-todo" class="w-4 h-4 inline mr-1"></i> Tasks
            </button>
            <button id="nav-history-btn" onclick="switchPage('history')" class="flex-1 py-2 px-3 sm:px-4 rounded-full text-xs sm:text-sm font-semibold transition-colors whitespace-nowrap bg-gray-700/50 hover:bg-gray-700">
                <i data-lucide="calendar" class="w-4 h-4 inline mr-1"></i> History
            </button>
            <button id="nav-achievements-btn" onclick="switchPage('achievements')" class="flex-1 py-2 px-3 sm:px-4 rounded-full text-xs sm:text-sm font-semibold transition-colors whitespace-nowrap bg-gray-700/50 hover:bg-gray-700">
                <i data-lucide="medal" class="w-4 h-4 inline mr-1"></i> Achievements
            </button>
            <button id="nav-progress-btn" onclick="switchPage('progress')" class="flex-1 py-2 px-3 sm:px-4 rounded-full text-xs sm:text-sm font-semibold transition-colors whitespace-nowrap bg-gray-700/50 hover:bg-gray-700">
                <i data-lucide="trending-up" class="w-4 h-4 inline mr-1"></i> Progress
            </button>
            <button id="nav-settings-btn" onclick="switchPage('settings')" class="flex-1 py-2 px-3 sm:px-4 rounded-full text-xs sm:text-sm font-semibold transition-colors whitespace-nowrap bg-gray-700/50 hover:bg-gray-700">
                <i data-lucide="settings" class="w-4 h-4 inline mr-1"></i> Settings
            </button>
        </nav>

        <main class="glass-base rounded-3xl p-5 sm:p-6 lg:p-8 shadow-2xl bg-gray-900/40">
            <div id="timer-view">
                <div id="timer-card" class="glass-base p-6 rounded-3xl shadow-2xl mb-8 bg-gray-800/30 border-gray-500/50">
                    <div class="flex justify-between items-center mb-4">
                        <h1 id="timer-title" class="text-2xl font-bold text-indigo-300">Focused Subject Tracker</h1>
                        <button id="music-btn" onclick="toggleSongPlayback()" class="p-2 rounded-full text-gray-400 hover:bg-white/10 transition-colors">
                            <i data-lucide="music" class="w-6 h-6"></i>
                        </button>
                    </div>
                    
                    <div class="text-center mb-6">
                        <p id="time-display" class="text-7xl lg:text-8xl font-extrabold tabular-nums tracking-tighter">00:00:00</p>
                    </div>
                    
                    <div class="mb-8 flex flex-col sm:flex-row justify-center items-center sm:space-x-6 space-y-4 sm:space-y-0 py-2">
                        <div class="relative w-24 h-24 flex-shrink-0">
                            <svg class="w-full h-full transform -rotate-90" viewBox="0 0 70 70">
                                <circle class="text-gray-700/50" stroke-width="6" stroke="currentColor" fill="transparent" r="30" cx="35" cy="35"></circle>
                                <circle id="streak-progress-bar" class="text-emerald-400 transition-all duration-700 ease-out" stroke-width="6" stroke="currentColor" stroke-linecap="round" fill="transparent" r="30" cx="35" cy="35" style="stroke-dasharray: 188.5; stroke-dashoffset: 188.5;"></circle>
                            </svg>
                            <span id="streak-progress-percent" class="absolute inset-0 flex items-center justify-center text-sm font-bold text-gray-300">0%</span>
                        </div>
                        <div class="flex-grow text-center sm:text-left">
                            <div class="text-sm text-gray-400 mb-1">Current Daily Focus Streak</div>
                            <div class="flex items-center justify-center sm:justify-start">
                                <i data-lucide="flame" class="w-8 h-8 mr-3 text-red-400"></i>
                                <span id="streak-count" class="text-5xl font-extrabold text-red-300 tabular-nums">0</span>
                            </div>
                            <div id="next-streak-info" class="text-xs text-gray-500 mt-2"></div>
                        </div>
                    </div>

                    <div class="mb-6">
                        <label class="block text-sm font-medium mb-2 text-gray-300">Select Subject</label>
                        <div id="subject-selector" class="flex flex-wrap gap-2"></div>
                    </div>

                    <div class="mb-8">
                        <label for="task-input" class="block text-sm font-medium mb-2 text-gray-300">Session Goal</label>
                        <div class="flex items-center bg-white/10 rounded-full p-3">
                            <i data-lucide="target" class="w-5 h-5 mr-3 text-indigo-400 flex-shrink-0"></i>
                            <input id="task-input" type="text" maxlength="100" placeholder="What do you want to accomplish?" class="w-full bg-transparent text-white placeholder-gray-400 focus:outline-none">
                        </div>
                    </div>
                    
                    <div class="mb-8">
                        <label class="block text-sm font-medium mb-2 text-gray-300">Select Timer Mode</label>
                        <div id="preset-selector" class="flex space-x-3 justify-center flex-wrap gap-2">
                            <button id="preset-free-btn" onclick="setTimerMode('free')" class="flex-1 p-3 rounded-lg font-semibold transition-colors bg-indigo-600/70 hover:bg-indigo-600 border border-transparent min-w-[120px]">
                                <i data-lucide="sun" class="w-5 h-5 inline mr-1"></i> Free Mode
                            </button>
                            <button id="preset-25-5-btn" onclick="setTimerMode('25/5')" class="flex-1 p-3 rounded-lg font-semibold transition-colors bg-gray-700/50 hover:bg-gray-600/70 border border-transparent min-w-[120px]">
                                <i data-lucide="timer" class="w-5 h-5 inline mr-1"></i> 25/5 Pomodoro
                            </button>
                            <button id="preset-50-10-btn" onclick="setTimerMode('50/10')" class="flex-1 p-3 rounded-lg font-semibold transition-colors bg-gray-700/50 hover:bg-gray-600/70 border border-transparent min-w-[120px]">
                                <i data-lucide="clock" class="w-5 h-5 inline mr-1"></i> 50/10 Focus
                            </button>
                        </div>
                    </div>

                    <div class="flex justify-center space-x-4 flex-wrap gap-2">
                        <button id="start-pause-btn" onclick="startPauseHandler()" class="p-4 rounded-full shadow-2xl transition-all transform hover:scale-105 active:scale-95 bg-green-500 hover:bg-green-600">
                            <i data-lucide="play" class="w-6 h-6"></i>
                        </button>
                        <button id="stop-btn" onclick="stopSession()" disabled class="p-4 rounded-full bg-red-600/70 hover:bg-red-600 shadow-2xl transition-all transform hover:scale-105 active:scale-95">
                            <i data-lucide="square" class="w-6 h-6"></i>
                        </button>
                        <button id="discard-btn" onclick="discardSession()" disabled class="p-4 rounded-full bg-gray-700/50 hover:bg-gray-600/70 shadow-2xl transition-all transform hover:scale-105 active:scale-95">
                            <i data-lucide="x-circle" class="w-6 h-6"></i>
                        </button>
                        <button id="fullscreen-btn" onclick="toggleFullscreenClock()" class="p-4 rounded-full bg-indigo-600/70 hover:bg-indigo-600 shadow-2xl transition-all transform hover:scale-105 active:scale-95">
                            <i data-lucide="maximize" class="w-6 h-6"></i>
                        </button>
                    </div>
                </div>

                <div class="glass-base mt-8 p-4 rounded-3xl shadow-xl bg-gray-800/50 border-gray-700/50">
                    <h2 class="text-xl font-semibold mb-3 text-center text-gray-300 flex items-center justify-center">
                        <i data-lucide="history" class="w-5 h-5 mr-2 text-gray-400"></i>
                        Recent Focus Sessions
                    </h2>
                    <div id="history-list" class="max-h-48 overflow-y-auto space-y-2"></div>
                    <div id="no-history" class="empty-state hidden">
                        <div class="empty-state-icon">📚</div>
                        <p class="text-gray-400">No sessions yet. Start your first focus session!</p>
                    </div>
                </div>
            </div>
            
            <div id="tasks-view" class="hidden">
                <div class="glass-base p-6 rounded-3xl shadow-2xl mb-8 bg-gray-800/30 border-gray-500/50">
                    <h1 class="text-2xl font-bold text-indigo-300 mb-4">Task List</h1>
                    
                    <div class="mb-6 space-y-3">
                        <div class="flex space-x-3">
                            <div class="flex items-center bg-white/10 rounded-full p-3 flex-grow">
                                <i data-lucide="plus-circle" class="w-5 h-5 mr-3 text-emerald-400 flex-shrink-0"></i>
                                <input id="new-task-input" type="text" maxlength="200" placeholder="Add a new task..." class="w-full bg-transparent text-white placeholder-gray-400 focus:outline-none" onkeypress="if(event.key === 'Enter') addTask()">
                            </div>
                            <button onclick="addTask()" class="p-3 rounded-full bg-emerald-600 hover:bg-emerald-700 transition-colors flex-shrink-0">
                                <i data-lucide="send" class="w-6 h-6"></i>
                            </button>
                        </div>
                        
                        <div class="flex space-x-2">
                            <select id="task-priority" class="p-2 rounded-lg bg-gray-700 border border-gray-600 text-white text-sm flex-shrink-0">
                                <option value="low">Low Priority</option>
                                <option value="medium" selected>Medium Priority</option>
                                <option value="high">High Priority</option>
                            </select>
                            <input id="task-due-date" type="date" class="p-2 rounded-lg bg-gray-700 border border-gray-600 text-white text-sm flex-grow">
                        </div>
                    </div>

                    <div id="tasks-list" class="space-y-3 max-h-96 overflow-y-auto"></div>
                    <div id="no-tasks" class="empty-state hidden">
                        <div class="empty-state-icon">✅</div>
                        <p class="text-gray-400">No tasks yet. Add your first task above!</p>
                    </div>
                </div>
            </div>
            
            <div id="history-view" class="hidden">
                <div class="glass-base p-6 rounded-3xl shadow-2xl mb-8 bg-gray-800/30 border-gray-500/50">
                    <div class="flex justify-between items-start mb-4 flex-wrap gap-3">
                        <h1 class="text-2xl font-bold text-indigo-300">Daily Focus History</h1>
                        <div class="flex space-x-2 flex-wrap">
                            <button onclick="exportData()" class="p-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 transition-colors text-sm flex items-center">
                                <i data-lucide="download" class="w-4 h-4 mr-2"></i>
                                Export JSON
                            </button>
                            <button onclick="exportCsvData()" class="p-2 rounded-lg bg-emerald-600 hover:bg-emerald-700 transition-colors text-sm flex items-center">
                                <i data-lucide="download" class="w-4 h-4 mr-2"></i>
                                Export CSV
                            </button>
                        </div>
                    </div>
                    
                    <div class="mb-6 flex space-x-3">
                        <input id="history-search" type="text" placeholder="Search sessions..." class="flex-grow p-3 rounded-lg bg-gray-700 border border-gray-600 text-white placeholder-gray-400 focus:ring-indigo-500 focus:border-indigo-500">
                        <select id="date-selector" onchange="handleDateChange(this.value)" class="p-3 rounded-lg bg-gray-700 border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500 flex-shrink-0">
                            <option value="">Select Date</option>
                        </select>
                    </div>

                    <div id="daily-summary-container" class="space-y-6">
                        <div class="empty-state">
                            <div class="empty-state-icon">📅</div>
                            <p class="text-gray-400">Select a date to view your study summary</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="achievements-view" class="hidden">
                <div class="glass-base p-6 rounded-3xl shadow-2xl mb-8 bg-gray-800/30 border-gray-500/50">
                    <h1 class="text-2xl font-bold text-emerald-300 mb-6">Trophy Case</h1>
                    <p class="text-gray-400 mb-6">Earn achievements by hitting focus and task milestones.</p>
                    <div id="trophies-container" class="grid grid-cols-1 md:grid-cols-2 gap-6"></div>
                </div>
            </div>
            
            <div id="progress-view" class="hidden">
                <div class="glass-base p-6 rounded-3xl shadow-2xl mb-8 bg-gray-800/30 border-gray-500/50">
                    <h1 class="text-2xl font-bold text-indigo-300 mb-6">Cumulative Progress</h1>
                    <div id="metrics-container" class="grid grid-cols-2 md:grid-cols-3 gap-4 sm:gap-6 mb-8"></div>
                    
                    <h2 class="text-xl font-semibold text-gray-300 mt-8 mb-4 border-b border-gray-700 pb-2 flex items-center">
                        <i data-lucide="bar-chart-2" class="w-5 h-5 mr-2"></i> Weekly Focus Breakdown
                    </h2>
                    <canvas id="weeklyChart" class="max-h-64"></canvas>
                    
                    <h2 class="text-xl font-semibold text-gray-300 mt-8 mb-4 border-b border-gray-700 pb-2 flex items-center">
                        <i data-lucide="pie-chart" class="w-5 h-5 mr-2"></i> Subject Distribution
                    </h2>
                    <canvas id="subjectChart" class="max-h-64"></canvas>
                </div>
            </div>

            <div id="settings-view" class="hidden">
                <div class="glass-base p-6 rounded-3xl shadow-2xl mb-8 bg-gray-800/30 border-gray-500/50">
                    <h1 class="text-2xl font-bold text-yellow-300 mb-6">Application Settings</h1>
                    
                    <div class="mb-8">
                        <h2 class="text-xl font-semibold text-gray-300 mb-4 border-b border-gray-700 pb-2 flex items-center">
                            <i data-lucide="award" class="w-5 h-5 mr-2"></i> Daily Streak Goal
                        </h2>
                        <div class="flex flex-col sm:flex-row sm:items-center space-y-3 sm:space-y-0 sm:space-x-4">
                            <label for="daily-goal-input" class="text-gray-400 font-medium flex-shrink-0">Daily Focus Goal (Minutes):</label>
                            <input id="daily-goal-input" type="number" min="5" value="30" class="w-full sm:w-24 p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-yellow-500 focus:border-yellow-500 focus:outline-none text-center" onchange="updateDailyGoal(this.value)">
                        </div>
                        <p class="text-sm text-gray-500 mt-2">Set the minimum focus time required to keep your daily streak alive.</p>
                    </div>
                    
                    <div class="mb-8">
                        <h2 class="text-xl font-semibold text-gray-300 mb-4 border-b border-gray-700 pb-2 flex items-center">
                            <i data-lucide="book-open-check" class="w-5 h-5 mr-2"></i> Subject Management
                        </h2>
                        <div class="mb-6 flex space-x-3">
                            <div class="flex items-center bg-white/10 rounded-full p-3 flex-grow">
                                <i data-lucide="book-open" class="w-5 h-5 mr-3 text-yellow-400 flex-shrink-0"></i>
                                <input id="new-subject-input" type="text" maxlength="30" placeholder="Enter new subject name" class="w-full bg-transparent text-white placeholder-gray-400 focus:outline-none" onkeypress="if(event.key === 'Enter') addSubjectHandler()">
                            </div>
                            <button onclick="addSubjectHandler()" class="p-3 rounded-full bg-yellow-600 hover:bg-yellow-700 transition-colors flex-shrink-0">
                                <i data-lucide="plus" class="w-6 h-6"></i>
                            </button>
                        </div>
                        <div id="subjects-list-manager" class="space-y-3 max-h-96 overflow-y-auto pt-2"></div>
                    </div>
                    
                    <div class="mb-8">
                        <h2 class="text-xl font-semibold text-gray-300 mb-4 border-b border-gray-700 pb-2 flex items-center">
                            <i data-lucide="database" class="w-5 h-5 mr-2"></i> Data Management
                        </h2>
                        <div class="space-y-3">
                            <button onclick="exportData()" class="w-full p-3 rounded-lg bg-indigo-600 hover:bg-indigo-700 transition-colors flex items-center justify-center">
                                <i data-lucide="download" class="w-5 h-5 mr-2"></i>
                                Export All Data (JSON)
                            </button>
                            <button onclick="exportCsvData()" class="w-full p-3 rounded-lg bg-emerald-600 hover:bg-emerald-700 transition-colors flex items-center justify-center">
                                <i data-lucide="file-text" class="w-5 h-5 mr-2"></i>
                                Export Sessions (CSV)
                            </button>
                            <button onclick="document.getElementById('import-file').click()" class="w-full p-3 rounded-lg bg-emerald-600 hover:bg-emerald-700 transition-colors flex items-center justify-center">
                                <i data-lucide="upload" class="w-5 h-5 mr-2"></i>
                                Import Data (JSON)
                            </button>
                            <input type="file" id="import-file" accept=".json" class="hidden" onchange="importData(event)">
                            <button onclick="clearAllData()" class="w-full p-3 rounded-lg bg-red-600 hover:bg-red-700 transition-colors flex items-center justify-center">
                                <i data-lucide="trash-2" class="w-5 h-5 mr-2"></i>
                                Clear All Data
                            </button>
                        </div>
                    </div>
                    
                    <div class="mb-8">
                        <h2 class="text-xl font-semibold text-gray-300 mb-4 border-b border-gray-700 pb-2 flex items-center">
                            <i data-lucide="keyboard" class="w-5 h-5 mr-2"></i> Keyboard Shortcuts
                        </h2>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between p-2 bg-gray-800/50 rounded">
                                <span class="text-gray-400">Start Timer (only)</span>
                                <kbd class="px-2 py-1 bg-gray-700 rounded">Space</kbd>
                            </div>
                            <div class="flex justify-between p-2 bg-gray-800/50 rounded">
                                <span class="text-gray-400">Stop Session</span>
                                <kbd class="px-2 py-1 bg-gray-700 rounded">S</kbd>
                            </div>
                            <div class="flex justify-between p-2 bg-gray-800/50 rounded">
                                <span class="text-gray-400">Discard Session</span>
                                <kbd class="px-2 py-1 bg-gray-700 rounded">D</kbd>
                            </div>
                            <div class="flex justify-between p-2 bg-gray-800/50 rounded">
                                <span class="text-gray-400">Toggle Fullscreen</span>
                                <kbd class="px-2 py-1 bg-gray-700 rounded">F</kbd>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div id="details-modal" class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-40 p-4" onclick="if(event.target === this) closeModal()">
        <div class="w-full max-w-md bg-gray-900 border border-indigo-600/50 rounded-xl p-6 shadow-2xl">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-indigo-400 flex items-center">
                    <i data-lucide="file-text" class="w-5 h-5 mr-2"></i>
                    Session Details
                </h3>
                <button onclick="deleteSession(currentSessionId)" class="p-2 rounded-full text-red-400 hover:bg-white/10 transition-colors">
                    <i data-lucide="trash-2" class="w-5 h-5"></i>
                </button>
            </div>
            <div id="modal-content" class="text-gray-300 whitespace-pre-wrap mb-4"></div>
            <div class="flex space-x-3">
                <button onclick="closeModal()" class="flex-1 p-3 rounded-full font-semibold transition-colors bg-gray-700 hover:bg-gray-600">
                    Close
                </button>
            </div>
        </div>
    </div>
    
    <div id="fullscreen-clock-modal" class="hidden fixed inset-0 bg-black/95 z-50 flex flex-col items-center justify-center p-4">
        <button onclick="toggleFullscreenClock()" class="absolute top-6 right-6 p-3 rounded-full text-white bg-white/10 hover:bg-white/20 transition-colors z-50">
            <i data-lucide="minimize" class="w-8 h-8"></i>
        </button>
        <div class="text-center">
            <p id="fullscreen-time-display" class="text-white text-[12rem] lg:text-[18rem] xl:text-[25rem] font-extrabold tabular-nums tracking-tighter">00:00:00</p>
            <p id="fullscreen-subject-goal" class="text-4xl font-semibold text-indigo-400 mt-4"></p>
        </div>
    </div>
    
    <audio id="music-player" preload="auto"></audio>
    <div id="toast-container"></div>

    <script>
        const LOCAL_STORAGE_KEY = 'studyTrackerProData';
        const CIRCLE_CIRCUMFERENCE = 2 * Math.PI * 30;
        
        // NEW: Timer Presets Configuration
        const PRESETS = {
            'free': { focus: Infinity, break: 0, name: 'Free Mode', icon: 'sun', color: 'indigo' },
            '25/5': { focus: 25 * 60, break: 5 * 60, name: '25/5 Pomodoro', icon: 'timer', color: 'emerald' },
            '50/10': { focus: 50 * 60, break: 10 * 60, name: '50/10 Focus', icon: 'clock', color: 'yellow' }
        };
        
        const SUBJECT_COLORS = ['indigo', 'emerald', 'sky', 'yellow', 'red', 'purple', 'teal', 'pink'];
        const DEFAULT_SUBJECTS = [
            { id: 'physics', name: 'Physics', color: 'indigo' },
            { id: 'chemistry', name: 'Chemistry', color: 'emerald' },
            { id: 'math', name: 'Math', color: 'sky' },
            { id: 'other', name: 'Other', color: 'yellow' },
            { id: 'lang', name: 'Language', color: 'red' },
        ];
        
        const ACHIEVEMENTS_CONFIG = [
            { id: 'focused_hour_easy', icon: 'hourglass', name: 'First Step (1h)', unit: 'minutes', description: 'Log one hour of focused time.', goal: 60, color: 'text-amber-300' },
            { id: 'focused_hour_medium', icon: 'hourglass', name: 'Time Manager (5h)', unit: 'minutes', description: 'Log five hours of focused time.', goal: 300, color: 'text-gray-300' },
            { id: 'focused_hour_hard', icon: 'hourglass', name: 'Flow State Master (20h)', unit: 'minutes', description: 'Log twenty hours of focused time.', goal: 1200, color: 'text-indigo-400' },
            { id: 'tasks_done_easy', icon: 'check-circle', name: 'Getting Things Done (5)', unit: 'tasks', description: 'Complete 5 tasks.', goal: 5, color: 'text-amber-300' },
            { id: 'tasks_done_medium', icon: 'check-circle', name: 'Productivity Pro (20)', unit: 'tasks', description: 'Complete 20 tasks.', goal: 20, color: 'text-gray-300' },
            { id: 'tasks_done_hard', icon: 'check-circle', name: 'Executioner (50)', unit: 'tasks', description: 'Complete 50 tasks.', goal: 50, color: 'text-indigo-400' }
        ];

        const DEFAULT_STATE = {
            isRunning: false,
            timeElapsed: 0,
            startTime: null,
            lastTickTime: null, // ADDED: Tracks the wall clock time for time correction
            subjects: DEFAULT_SUBJECTS,
            currentSubject: DEFAULT_SUBJECTS[0].id,
            sessionGoal: '',
            sessions: [],
            tasks: [],
            currentPage: 'timer',
            totalFocusTime: 0,
            isPomodoroActive: false,
            pomodoroMode: 'focus',
            pomodoroTimeRemaining: 0, // Will be initialized by setTimerMode on load
            currentDailyStreak: 0,
            lastActiveDate: null,
            dailyFocusGoalMinutes: 30,
            dailyTimeLogged: 0,
            unlockedAchievements: [],
            longestDailyStreak: 0,
            timerMode: 'free', // NEW: Default mode is 'free'
        };

        let state = { ...DEFAULT_STATE };
        let intervalId = null;
        let currentSongIndex = 0;
        let currentSessionId = null;
        let weeklyChart = null;
        let subjectChart = null;
        
        const PLAYLIST = [
            'assets/song1.mp3',
            'assets/song2.mp3',
            'assets/song3.mp3',
            'assets/song4.mp3',
            'assets/song5.mp3',
        ];
        
        let stats = {
            overallTime: 0,
            monthlyTime: 0,
            weeklyTime: 0,
            prevMonthlyTime: 0,
            prevWeeklyTime: 0,
            dailyTimeInWeek: Array(7).fill(0),
            tasksCompleted: 0,
            totalTasks: 0,
            efficiency: 0,
            avgDailyHours: 0,
            avgSessionLengthSeconds: 0,
            achievements: {},
            subjectBreakdown: {},
            mostFocusedSubject: 'N/A',
            mostFocusedSubjectRatio: 0,
        };

        const D = {
            timerTitle: document.getElementById('timer-title'),
            timeDisplay: document.getElementById('time-display'),
            taskInput: document.getElementById('task-input'),
            startPauseBtn: document.getElementById('start-pause-btn'),
            stopBtn: document.getElementById('stop-btn'),
            discardBtn: document.getElementById('discard-btn'),
            musicBtn: document.getElementById('music-btn'),
            musicPlayer: document.getElementById('music-player'),
            // NEW: Preset Buttons
            presetFreeBtn: document.getElementById('preset-free-btn'),
            preset255Btn: document.getElementById('preset-25-5-btn'),
            preset5010Btn: document.getElementById('preset-50-10-btn'),
            // End NEW
            historyList: document.getElementById('history-list'),
            noHistory: document.getElementById('no-history'),
            subjectSelector: document.getElementById('subject-selector'),
            detailsModal: document.getElementById('details-modal'),
            modalContent: document.getElementById('modal-content'),
            streakProgressBar: document.getElementById('streak-progress-bar'),
            streakProgressPercent: document.getElementById('streak-progress-percent'),
            streakCount: document.getElementById('streak-count'),
            nextStreakInfo: document.getElementById('next-streak-info'),
            timerView: document.getElementById('timer-view'),
            tasksView: document.getElementById('tasks-view'),
            historyView: document.getElementById('history-view'),
            achievementsView: document.getElementById('achievements-view'),
            progressView: document.getElementById('progress-view'),
            settingsView: document.getElementById('settings-view'),
            navTimerBtn: document.getElementById('nav-timer-btn'),
            navTasksBtn: document.getElementById('nav-tasks-btn'),
            navHistoryBtn: document.getElementById('nav-history-btn'),
            navAchievementsBtn: document.getElementById('nav-achievements-btn'),
            navProgressBtn: document.getElementById('nav-progress-btn'),
            navSettingsBtn: document.getElementById('nav-settings-btn'),
            taskInputNew: document.getElementById('new-task-input'),
            taskPriority: document.getElementById('task-priority'),
            taskDueDate: document.getElementById('task-due-date'),
            tasksListContainer: document.getElementById('tasks-list'),
            noTasks: document.getElementById('no-tasks'),
            dateSelector: document.getElementById('date-selector'),
            historySearch: document.getElementById('history-search'),
            dailySummaryContainer: document.getElementById('daily-summary-container'),
            trophiesContainer: document.getElementById('trophies-container'),
            metricsContainer: document.getElementById('metrics-container'),
            weeklyChart: document.getElementById('weeklyChart'),
            subjectChart: document.getElementById('subjectChart'),
            fullscreenClockModal: document.getElementById('fullscreen-clock-modal'),
            fullscreenTimeDisplay: document.getElementById('fullscreen-time-display'),
            fullscreenSubjectGoal: document.getElementById('fullscreen-subject-goal'),
            fullscreenBtn: document.getElementById('fullscreen-btn'),
            newSubjectInput: document.getElementById('new-subject-input'),
            subjectsListManager: document.getElementById('subjects-list-manager'),
            dailyGoalInput: document.getElementById('daily-goal-input'),
            toastContainer: document.getElementById('toast-container'),
        };

        // UTILITIES
        function formatTime(totalSeconds, includeHours) {
            const totalSec = Math.max(0, Math.floor(totalSeconds));
            const hours = Math.floor(totalSec / 3600);
            const minutes = Math.floor((totalSec % 3600) / 60);
            const seconds = Math.floor(totalSec % 60);
            const minutesStr = minutes.toString().padStart(2, '0');
            const secondsStr = seconds.toString().padStart(2, '0');
            if (includeHours || hours > 0) {
                const hoursStr = hours.toString().padStart(2, '0');
                return `${hoursStr}:${minutesStr}:${secondsStr}`;
            }
            return `${minutesStr}:${secondsStr}`;
        }

        const formatMinutes = (seconds) => {
            const totalMinutes = Math.floor(seconds / 60);
            if (totalMinutes < 60) return `${totalMinutes} min`;
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            return `${hours}h ${minutes}m`;
        };

        function formatComparison(current, previous, unit) {
            if (previous === 0) return `<span class="text-gray-400">No previous ${unit} data</span>`;

            const change = current - previous;
            const percentChange = (change / previous) * 100;
            const formattedPercent = Math.abs(percentChange).toFixed(0);

            if (Math.abs(percentChange) < 1) return `<span class="text-gray-400">Same as last ${unit}</span>`;

            let icon = 'minus', color = 'text-gray-400', direction = 'No change';
            if (percentChange > 0) {
                icon = 'arrow-up-right';
                color = 'text-emerald-400';
                direction = 'Up';
            } else if (percentChange < 0) {
                icon = 'arrow-down-right';
                color = 'text-red-400';
                direction = 'Down';
            }

            return `<span class="${color} flex items-center"><i data-lucide="${icon}" class="w-4 h-4 mr-1"></i>${direction} ${formattedPercent}%</span>`;
        }

        function getFormattedDate(isoString) {
            if (!isoString) return null;
            return isoString.split('T')[0];
        }
        
        function formatDateForDisplay(dateKey) {
            const date = new Date(dateKey + 'T00:00:00');
            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric', timeZone: 'UTC' });
        }

        function getPeriodStart(period, referenceDate = new Date()) {
            const date = new Date(referenceDate.getTime());
            date.setHours(0, 0, 0, 0);

            if (period === 'week') {
                const day = date.getDay() || 7; // Monday is 1, Sunday is 0/7
                date.setDate(date.getDate() - day + 1);
                return date;
            } else if (period === 'prevWeek') {
                const startOfWeek = getPeriodStart('week', referenceDate);
                startOfWeek.setDate(startOfWeek.getDate() - 7);
                return startOfWeek;
            } else if (period === 'month') {
                date.setDate(1);
                return date;
            } else if (period === 'prevMonth') {
                date.setDate(1);
                date.setMonth(date.getMonth() - 1);
                return date;
            }
            return new Date(0); // Epoch
        }

        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = 'toast';
            if (type === 'error') toast.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
            if (type === 'info') toast.style.background = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
            toast.innerHTML = `<div class="flex items-center"><i data-lucide="${type === 'success' ? 'check-circle' : (type === 'error' ? 'alert-triangle' : 'info')}" class="w-5 h-5 mr-2"></i>${message}</div>`;
            D.toastContainer.appendChild(toast);
            window.createLucideIcons();
            setTimeout(() => toast.remove(), 3000);
        }

        // STORAGE
        function loadState() {
            try {
                const storedState = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (storedState) {
                    const loadedState = JSON.parse(storedState);
                    state = { ...DEFAULT_STATE, ...loadedState };

                    // Handle time difference if timer was running when app was closed
                    if (state.isRunning && state.startTime) {
                        const now = Date.now();
                        const timeAway = Math.floor((now - state.startTime) / 1000);
                        
                        if (state.isPomodoroActive) {
                            // Correct Pomodoro time
                            state.pomodoroTimeRemaining = Math.max(0, state.pomodoroTimeRemaining - timeAway);

                            if (state.pomodoroTimeRemaining <= 0) {
                                // If the time is past the end of the session, stop it and log the max duration
                                state.isRunning = false;
                                if (state.pomodoroMode === 'focus') {
                                    const maxDuration = PRESETS[state.timerMode].focus;
                                    logSession(maxDuration);
                                    // Manually transition to the next phase as if it just finished
                                    nextPomodoroPhase(true); 
                                } else if (state.pomodoroMode === 'break') {
                                    // Just end the break
                                    state.isPomodoroActive = false;
                                    setTimerMode('free');
                                }
                                showToast('Session corrected: Pomodoro finished while you were away.', 'info');
                            }
                        } else {
                            // Correct Free Mode time
                            state.timeElapsed += timeAway;
                        }
                    }
                    
                    // Streak maintenance check
                    checkStreakOnLoad();
                } else {
                    // Initial load: set pomodoro time
                    setTimerMode(state.timerMode);
                }

                calculateStats();
            } catch (e) {
                console.error("Could not load state:", e);
                // Fallback to default state
                state = DEFAULT_STATE;
                setTimerMode(state.timerMode);
            }
        }
        
        function checkStreakOnLoad() {
            const now = new Date();
            const todayKey = getFormattedDate(now.toISOString());
            const yesterday = new Date(now.getTime());
            yesterday.setDate(now.getDate() - 1);
            const yesterdayKey = getFormattedDate(yesterday.toISOString());
            
            const lastActiveKey = state.lastActiveDate ? getFormattedDate(state.lastActiveDate) : null;
            
            // Check if goal was met yesterday (for streak continuity)
            const goalMetYesterday = state.sessions.filter(s => getFormattedDate(s.timestamp) === yesterdayKey)
                                                  .reduce((total, s) => total + s.duration, 0) >= (state.dailyFocusGoalMinutes * 60);

            if (lastActiveKey && lastActiveKey !== todayKey) {
                // It is a new day
                if (lastActiveKey !== yesterdayKey || !goalMetYesterday) {
                    // Check if goal met today, to prevent streak reset on first load of the day
                    const goalMetToday = state.sessions.filter(s => getFormattedDate(s.timestamp) === todayKey)
                                                        .reduce((total, s) => total + s.duration, 0) >= (state.dailyFocusGoalMinutes * 60);

                    if(!goalMetToday) { 
                        state.currentDailyStreak = 0;
                        state.dailyTimeLogged = 0;
                    } else {
                        // If it's a new day and goal met today, but yesterday was missed, reset dailyTimeLogged
                        state.dailyTimeLogged = state.sessions.filter(s => getFormattedDate(s.timestamp) === todayKey)
                                                .reduce((total, s) => total + s.duration, 0);
                    }
                } else if (lastActiveKey === yesterdayKey && goalMetYesterday) {
                    // It is a new day (todayKey !== lastActiveKey) and goal met yesterday, so log today's time and potentially increment streak later
                    state.dailyTimeLogged = state.sessions.filter(s => getFormattedDate(s.timestamp) === todayKey)
                                            .reduce((total, s) => total + s.duration, 0);
                }
            } else if (lastActiveKey === todayKey) {
                // Still on the same day, update dailyTimeLogged
                state.dailyTimeLogged = state.sessions.filter(s => getFormattedDate(s.timestamp) === todayKey)
                                        .reduce((total, s) => total + s.duration, 0);
            }

            state.lastActiveDate = now.toISOString();
            saveState();
            calculateStats();
        }

        function saveState() {
            try {
                // Ensure state.isRunning is false before saving if a pomodoro ended or free timer wasn't manually started
                if (state.timerMode !== 'free' && state.isPomodoroActive && state.pomodoroTimeRemaining <= 0) {
                    state.isRunning = false;
                }
                
                const stateToSave = { ...state };
                // Do not save lastTickTime, it's a runtime variable
                delete stateToSave.lastTickTime; 
                
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(stateToSave));
            } catch (e) {
                console.error("Could not save state:", e);
            }
        }
        
        // TIMER LOGIC
        
        // REPLACED: Updated updateTimer using the Wall Clock method
        function updateTimer() {
            if (!state.isRunning) {
                if (intervalId) {
                    clearInterval(intervalId);
                    intervalId = null;
                }
                return;
            }

            const now = Date.now();
            if (!state.lastTickTime) {
                state.lastTickTime = now;
                return; // Wait for the next tick for calculation
            }
            
            // Calculate actual time passed in milliseconds and convert to seconds
            // Use Math.floor to ensure we only count full seconds elapsed.
            const timePassedMs = now - state.lastTickTime;
            let timePassedSeconds = Math.floor(timePassedMs / 1000); 

            if (timePassedSeconds <= 0) {
                // If less than a second passed, adjust lastTickTime and exit
                state.lastTickTime = now;
                updateUI(); 
                return; 
            }
            
            // Update the wall clock time for the next tick
            state.lastTickTime = now; 
            
            // ------------------------------------------------------------------
            // Core Timer Logic
            // ------------------------------------------------------------------
            let phaseChanged = false;

            if (state.isPomodoroActive) {
                // POMODORO MODE: Count down the remaining time
                state.pomodoroTimeRemaining = Math.max(0, state.pomodoroTimeRemaining - timePassedSeconds);

                if (state.pomodoroTimeRemaining <= 0) {
                    // Pomodoro phase finished
                    nextPomodoroPhase(); 
                    phaseChanged = true;
                    // nextPomodoroPhase handles updateUI/saveState/checkAchievements
                }
            } else {
                // FREE MODE: Count up the elapsed time
                state.timeElapsed += timePassedSeconds;
            }

            if (!phaseChanged) {
                updateUI();
                saveState();
                checkAchievements();
            }
        }
        // END REPLACED: updateTimer

        function getRemainingTime() {
            return state.isPomodoroActive ? state.pomodoroTimeRemaining : state.timeElapsed;
        }

        function setTimerMode(mode) {
            if (state.isRunning) {
                showToast('Cannot change mode while timer is running. Please stop first.', 'error');
                return;
            }
            
            const preset = PRESETS[mode];
            state.timerMode = mode;
            state.isPomodoroActive = (mode !== 'free');
            state.pomodoroMode = 'focus';
            state.timeElapsed = 0;
            state.pomodoroTimeRemaining = preset.focus;
            state.startTime = null; // We still clear the previous startTime context.
            
            // UI updates
            updateUI();
            
            // --- FIX: Update Preset button styles and ensure color is applied ---
            const btns = [D.presetFreeBtn, D.preset255Btn, D.preset5010Btn];
            btns.forEach(btn => {
                let btnMode = btn.id.replace('preset-', '').replace('-btn', '');
                // **CRITICAL FIX:** Normalize the btnMode string to match the 'mode' variable (e.g., '25-5' -> '25/5')
                btnMode = btnMode.replace(/-/g, '/');
                
                if (btnMode === mode) {
                    // Apply active styles (Indigo color)
                    btn.classList.add('bg-indigo-600/70', 'hover:bg-indigo-600');
                    btn.classList.remove('bg-gray-700/50', 'hover:bg-gray-600/70');
                    btn.classList.add('text-white');
                } else {
                    // Apply inactive styles (Gray color)
                    btn.classList.remove('bg-indigo-600/70', 'hover:bg-indigo-600', 'text-white');
                    btn.classList.add('bg-gray-700/50', 'hover:bg-gray-600/70');
                }
            });

            saveState();
        }

        // UPDATED: startPauseHandler to set lastTickTime
        function startPauseHandler() {
            if (state.isPomodoroActive && state.pomodoroTimeRemaining <= 0) {
                // Pomodoro ended, do not start/pause, wait for stopSession or next phase
                return;
            }
            if (state.isRunning) {
                // --- PAUSE LOGIC ---
                state.isRunning = false;
                if (intervalId) {
                    clearInterval(intervalId);
                    intervalId = null;
                }
                state.lastTickTime = null; // Clear wall clock reference on pause
            } else {
                // --- START LOGIC ---
                if (!state.currentSubject) {
                    showToast('Please select a subject before starting the timer.', 'error');
                    return;
                }

                state.isRunning = true;
                state.startTime = Date.now();
                state.lastTickTime = Date.now(); // ADDED: Set wall clock time on start/resume

                if (state.pomodoroTimeRemaining > 0) {
                    // Pomodoro Start or Resume
                    intervalId = setInterval(updateTimer, 1000);
                } else if (!state.isPomodoroActive) {
                    // Free Mode Start
                    intervalId = setInterval(updateTimer, 1000);
                } else {
                    // If pomodoro is active but time is 0 (should only happen after logging), re-init it
                    setTimerMode(state.timerMode);
                    startPauseHandler();
                    return;
                }
            }

            updateUI();
            saveState();
        }
        // END UPDATED: startPauseHandler


        function stopSession() {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            state.isRunning = false;
            state.lastTickTime = null; // Clear wall clock reference on stop

            const focusTime = state.isPomodoroActive 
                ? (PRESETS[state.timerMode].focus - state.pomodoroTimeRemaining)
                : state.timeElapsed;

            // Only log if it was a Pomodoro focus time OR Free mode time > 5 seconds
            if (focusTime > 5 || (state.isPomodoroActive && state.pomodoroMode === 'focus')) {
                logSession(focusTime);
                state.dailyTimeLogged += focusTime;
                checkDailyStreak(); // Check streak after logging session time
            } else if (focusTime > 0) {
                showToast(`Session too short (${formatMinutes(focusTime)}) to log.`, 'error');
            }

            // Reset state after logging
            if (state.isPomodoroActive && state.pomodoroTimeRemaining <= 0) {
                 // If the timer ended naturally (pomodoro finished), nextPomodoroPhase handles the new session start/break.
            } else {
                // If stopped manually, reset to the beginning of the focus session/free mode.
                setTimerMode(state.timerMode);
            }
            
            calculateStats();
            updateUI();
            saveState();
        }
        
        function discardSession() {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            state.isRunning = false;
            state.lastTickTime = null; // Clear wall clock reference on discard
            setTimerMode(state.timerMode);
            showToast('Session discarded. Time not logged.', 'info');
            updateUI();
            saveState();
        }

        function nextPomodoroPhase(isCorrection = false) {
            // Log the completed Focus Session only if the phase was 'focus' and it wasn't a manual stop
            if (state.pomodoroMode === 'focus' && !isCorrection) {
                // Duration is the full focus time, as it ran to zero
                const focusDuration = PRESETS[state.timerMode].focus;
                logSession(focusDuration);
                state.dailyTimeLogged += focusDuration;
                checkDailyStreak(); // Check streak after logging
                calculateStats();
            }

            // Only switch phase if the new time is > 0 (i.e., there is a break)
            if (state.pomodoroMode === 'focus') {
                // Logged focus time, now check if a break is needed (50/10 mode has a break)
                if (PRESETS[state.timerMode].break > 0) {
                    state.pomodoroMode = 'break';
                    state.pomodoroTimeRemaining = PRESETS[state.timerMode].break;
                    showToast(`Focus complete! Time for a ${formatMinutes(state.pomodoroTimeRemaining)} break.`, 'success');
                } else {
                    // No break, simply stop (e.g., if using a custom Pomodoro mode without a break)
                    state.isPomodoroActive = false;
                    setTimerMode('free'); // Revert to free mode
                    showToast(`Focus complete! Session logged.`, 'success');
                }
            } else if (state.pomodoroMode === 'break') {
                // End Break, go back to Focus
                state.pomodoroMode = 'focus';
                state.pomodoroTimeRemaining = PRESETS[state.timerMode].focus;
                showToast(`Break over! Time to focus again.`, 'success');
            }
            
            // Re-start the timer for the break/next focus session
            if (!isCorrection && state.isRunning) {
                state.lastTickTime = Date.now();
            } else if (!isCorrection && !state.isRunning) {
                // If it ended while paused, just update UI and wait for user to hit start
            } else if (isCorrection) {
                // If corrected after tab reactivation, the timer interval needs to be running
                if (intervalId) clearInterval(intervalId);
                intervalId = setInterval(updateTimer, 1000);
            }

            updateUI();
            saveState();
        }

        function logSession(durationOverride = state.timeElapsed) {
            const now = new Date();
            const session = {
                id: Date.now().toString(),
                timestamp: now.toISOString(),
                duration: durationOverride, // Use timeElapsed for free mode, or focus time for pomodoro
                subjectId: state.currentSubject,
                goal: D.taskInput.value.trim() || 'No goal set',
                mode: state.isPomodoroActive ? `${state.timerMode} (${state.pomodoroMode})` : 'Free Mode',
            };

            // Only log if duration is more than 5 seconds (to prevent logging accidental clicks)
            if (session.duration > 5) {
                state.sessions.unshift(session);
                showToast(`Session logged: ${formatMinutes(session.duration)} of focused time!`, 'success');
                
                // Update tasks: create an associated completed task
                if (D.taskInput.value.trim()) {
                    const task = {
                        id: 's' + session.id,
                        text: `[Focus Session] ${D.taskInput.value.trim()} (${formatMinutes(session.duration)})`,
                        completed: true,
                        priority: 'low',
                        timestamp: session.timestamp,
                        dueDate: null,
                    };
                    state.tasks.unshift(task);
                }
            }
        }

        function checkDailyStreak() {
            const goalSeconds = state.dailyFocusGoalMinutes * 60;
            const now = new Date();
            const todayKey = getFormattedDate(now.toISOString());
            const yesterday = new Date(now.getTime());
            yesterday.setDate(now.getDate() - 1);
            const yesterdayKey = getFormattedDate(yesterday.toISOString());
            
            const lastActiveKey = state.lastActiveDate ? getFormattedDate(state.lastActiveDate) : null;
            
            const goalMetToday = state.dailyTimeLogged >= goalSeconds;

            if (goalMetToday && lastActiveKey !== todayKey) {
                // Check if the streak was active yesterday or if it's the very first session
                if (state.currentDailyStreak > 0) {
                    // Check if yesterday's goal was met to determine if we continue or reset
                    const goalMetYesterday = state.sessions.filter(s => getFormattedDate(s.timestamp) === yesterdayKey)
                                                        .reduce((total, s) => total + s.duration, 0) >= goalSeconds;
                    
                    if (goalMetYesterday) {
                        state.currentDailyStreak += 1;
                        showToast(`🔥 Streak continued! Now ${state.currentDailyStreak} days!`, 'success');
                    } else {
                        // Missed a day
                        state.currentDailyStreak = 1;
                        showToast(`Streak reset, but a new streak has begun!`, 'info');
                    }
                } else {
                    // First day of streak
                    state.currentDailyStreak = 1;
                    showToast(`🔥 First day of your focus streak!`, 'success');
                }
            } else if (lastActiveKey !== todayKey) {
                // New day, but goal not met today (yet) and if yesterday's goal wasn't met, reset streak
                const goalMetYesterday = state.sessions.filter(s => getFormattedDate(s.timestamp) === yesterdayKey)
                                                        .reduce((total, s) => total + s.duration, 0) >= goalSeconds;
                if (!goalMetYesterday) {
                    state.currentDailyStreak = 0;
                }
            }

            state.longestDailyStreak = Math.max(state.longestDailyStreak, state.currentDailyStreak);
            state.lastActiveDate = now.toISOString();
            saveState();
        }

        // AUTO-CLEANUP
        function filterExpiredTasks() {
            const today = getFormattedDate(new Date().toISOString());
            let tasksChanged = false;

            // Filter the state.tasks array
            const activeTasks = state.tasks.filter(task => {
                // 1. Completed tasks are always kept (for history/metrics).
                if (task.completed) {
                    return true;
                }
                // 2. Tasks without a dueDate are kept (they have no deadline).
                if (!task.dueDate) {
                    return true;
                }
                // 3. If the dueDate is today or in the future, we keep it.
                // String comparison works correctly for YYYY-MM-DD format.
                if (task.dueDate >= today) {
                    return true; // Keep the task
                }
                // 4. If none of the above, the task is UNCOMPLETED and PAST DUE.
                tasksChanged = true;
                return false; // Remove the expired task
            });

            // Only update and save state if tasks were actually removed
            if (tasksChanged) {
                state.tasks = activeTasks;
                saveState();
                showToast('Expired tasks have been automatically cleared from the list. ✅', 'info');
            }
        }

        // UI UPDATES
        // UPDATED: updateUI to use totalFocusTimeToday for streak
        function updateUI() {
            const timeToDisplay = state.isPomodoroActive ? state.pomodoroTimeRemaining : state.timeElapsed;
            D.timeDisplay.textContent = formatTime(timeToDisplay, true);
            D.fullscreenTimeDisplay.textContent = formatTime(timeToDisplay, true);

            // Pomodoro Title Update
            if (state.isPomodoroActive) {
                const currentMode = PRESETS[state.timerMode];
                const modeText = state.pomodoroMode === 'focus' ? 'Focus Time' : 'Break Time';
                D.timerTitle.innerHTML = `<i data-lucide="${currentMode.icon}" class="w-6 h-6 inline mr-2 text-${currentMode.color}-400"></i> ${currentMode.name}: ${modeText}`;
            } else {
                D.timerTitle.textContent = 'Focused Subject Tracker';
            }
            window.createLucideIcons(); // Update icons in title

            // Stop/Discard Button states
            if (state.isPomodoroActive) {
                D.stopBtn.disabled = !state.isRunning || state.pomodoroMode === 'break';
                D.discardBtn.disabled = !state.isRunning || state.pomodoroMode === 'break';
                D.startPauseBtn.innerHTML = `<i data-lucide="${state.isRunning ? 'pause' : 'play'}" class="w-6 h-6"></i>`;
                // Pomodoro only allows pausing, not stopping or discarding, if it's a break
                if (state.pomodoroMode === 'break') {
                    D.startPauseBtn.innerHTML = `<i data-lucide="${state.isRunning ? 'pause' : 'play'}" class="w-6 h-6 text-yellow-400"></i>`;
                    D.stopBtn.disabled = true;
                    D.discardBtn.disabled = true;
                }

            } else {
                const hasTimeElapsed = state.timeElapsed > 0;
                D.stopBtn.disabled = !state.isRunning && !hasTimeElapsed;
                D.discardBtn.disabled = !state.isRunning && !hasTimeElapsed;
                D.startPauseBtn.innerHTML = `<i data-lucide="${state.isRunning ? 'pause' : 'play'}" class="w-6 h-6"></i>`;
            }

            // Music button icon
            const musicIcon = D.musicPlayer.paused ? 'music' : 'volume-2';
            
            // FIX: Add null check for the icon element to prevent TypeError (index.html:1200)
            const musicIconElement = D.musicBtn.querySelector('i');
            if (musicIconElement) {
                musicIconElement.setAttribute('data-lucide', musicIcon);
            }
            // END FIX
            
            window.createLucideIcons(); // To update the music button icon

            // Task input state
            D.taskInput.disabled = state.isRunning;


            // Streak Progress Bar
            // Calculate Total Focus Time Today (Completed Sessions + Current Running Session)
            let currentSessionTime = 0;
            if (state.isRunning) {
                if (state.isPomodoroActive && state.pomodoroMode === 'focus') {
                    // For Pomodoro Focus mode, time is calculated by: Total Focus Time - Time Remaining
                    currentSessionTime = PRESETS[state.timerMode].focus - state.pomodoroTimeRemaining;
                } else if (!state.isPomodoroActive) {
                    // For Free Mode, time is simply the time elapsed
                    currentSessionTime = state.timeElapsed;
                }
            }
            
            // This is the total time for the streak check
            const totalFocusTimeToday = state.dailyTimeLogged + currentSessionTime;
            
            const goalSeconds = state.dailyFocusGoalMinutes * 60;
            const progress = Math.min(1, totalFocusTimeToday / goalSeconds); // Use totalFocusTimeToday
            const offset = CIRCLE_CIRCUMFERENCE * (1 - progress);
            D.streakProgressBar.style.strokeDashoffset = offset;
            D.streakProgressPercent.textContent = `${Math.floor(progress * 100)}%`;
            D.streakCount.textContent = state.currentDailyStreak;

            const remainingMinutes = Math.max(0, state.dailyFocusGoalMinutes - Math.floor(totalFocusTimeToday / 60)); // Use totalFocusTimeToday
            if (remainingMinutes > 0) {
                D.nextStreakInfo.textContent = `Log ${remainingMinutes} more minutes to secure your streak!`;
                D.nextStreakInfo.classList.remove('text-emerald-400');
                D.nextStreakInfo.classList.add('text-gray-500');
            } else {
                D.nextStreakInfo.textContent = `Daily goal complete! Keep the streak alive!`;
                D.nextStreakInfo.classList.add('text-emerald-400');
                D.nextStreakInfo.classList.remove('text-gray-500');
            }

            // Fullscreen clock info
            const currentSubject = state.subjects.find(s => s.id === state.currentSubject);
            D.fullscreenSubjectGoal.textContent = `${currentSubject ? currentSubject.name : 'Subject'} | ${D.taskInput.value.trim() || 'No Goal'}`;

            renderHistory('', '', 5);
            window.createLucideIcons();
        }
        // END UPDATED: updateUI

        // SUBJECTS
        function renderSubjectSelector() {
            D.subjectSelector.innerHTML = state.subjects.map(subject => {
                const isChecked = subject.id === state.currentSubject;
                const activeClasses = isChecked ? `bg-${subject.color}-600 border-${subject.color}-400 text-white shadow-lg shadow-${subject.color}-600/50` : `bg-gray-700/50 border-gray-600 text-gray-300 hover:bg-gray-600/70`;
                return `
                    <input type="radio" id="subject-${subject.id}" name="subject-select" value="${subject.id}" class="hidden subject-radio" ${isChecked ? 'checked' : ''} onclick="selectSubject('${subject.id}')">
                    <label for="subject-${subject.id}" class="p-3 rounded-lg font-semibold transition-all cursor-pointer border ${activeClasses}">
                        ${subject.name}
                    </label>
                `;
            }).join('');
        }

        function selectSubject(subjectId) {
            state.currentSubject = subjectId;
            saveState();
            renderSubjectSelector();
            updateUI(); // To update fullscreen subject info
        }

        function addSubjectHandler() {
            const name = D.newSubjectInput.value.trim();
            if (!name) {
                showToast('Subject name cannot be empty.', 'error');
                return;
            }
            if (state.subjects.some(s => s.name.toLowerCase() === name.toLowerCase())) {
                showToast('Subject already exists.', 'error');
                return;
            }

            const newSubject = {
                id: name.toLowerCase().replace(/\s/g, '_'),
                name: name,
                // Cycle through colors
                color: SUBJECT_COLORS[state.subjects.length % SUBJECT_COLORS.length]
            };

            state.subjects.push(newSubject);
            D.newSubjectInput.value = '';
            showToast('Subject added successfully!', 'success');
            saveState();
            renderSubjectSelector();
            renderSubjectManager();
            calculateStats();
        }

        function renderSubjectManager() {
            D.subjectsListManager.innerHTML = state.subjects.map(subject => {
                return `
                    <div class="flex items-center p-3 bg-gray-700/50 rounded-lg justify-between">
                        <span class="text-gray-300 border-l-4 border-${subject.color}-500 pl-3">${subject.name}</span>
                        <button onclick="removeSubject('${subject.id}')" class="p-1 rounded-full text-red-400 hover:bg-white/10 transition-colors">
                            <i data-lucide="trash-2" class="w-5 h-5"></i>
                        </button>
                    </div>
                `;
            }).join('');
            window.createLucideIcons();
        }

        function removeSubject(subjectId) {
            if (state.subjects.length <= 1) {
                showToast('Cannot remove the last subject.', 'error');
                return;
            }
            if (state.currentSubject === subjectId) {
                state.currentSubject = state.subjects.find(s => s.id !== subjectId).id;
            }
            state.subjects = state.subjects.filter(s => s.id !== subjectId);
            showToast('Subject removed.', 'success');
            saveState();
            renderSubjectSelector();
            renderSubjectManager();
        }

        // TASKS
        function renderTasks() {
            if (state.tasks.length === 0) {
                D.tasksListContainer.innerHTML = '';
                D.noTasks.classList.remove('hidden');
                return;
            }
            D.noTasks.classList.add('hidden');

            // Sort: Incomplete tasks first, then by priority (high > medium > low), then by due date
            const sortedTasks = [...state.tasks].sort((a, b) => {
                // 1. Completion status (incomplete first)
                if (a.completed !== b.completed) {
                    return a.completed ? 1 : -1;
                }
                // 2. Priority
                const priorityOrder = { high: 1, medium: 2, low: 3 };
                if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
                    return priorityOrder[a.priority] - priorityOrder[b.priority];
                }
                // 3. Due Date (earliest first)
                return (a.dueDate || '9999-12-31').localeCompare(b.dueDate || '9999-12-31');
            });

            D.tasksListContainer.innerHTML = sortedTasks.map(task => {
                const priorityClass = `priority-${task.priority}`;
                const completionClass = task.completed ? 'opacity-50 line-through' : 'hover:bg-gray-700/70';
                const dateDisplay = task.dueDate ? `Due: ${task.dueDate}` : 'No Due Date';
                const completionIcon = task.completed ? 'refresh-ccw' : 'check-circle';
                const completionText = task.completed ? 'Mark as Incomplete' : 'Complete Task';

                return `
                    <div id="task-${task.id}" class="flex items-start p-3 bg-gray-800/50 rounded-lg shadow-md transition-all ${priorityClass} ${completionClass}">
                        <input type="checkbox" class="mt-1 flex-shrink-0" id="checkbox-${task.id}" ${task.completed ? 'checked' : ''} onclick="toggleTaskCompletion('${task.id}')">
                        <div class="flex-grow ml-3">
                            <p class="text-sm font-medium text-gray-100">${task.text}</p>
                            <p class="text-xs text-gray-400 mt-1">${dateDisplay} | Priority: <span class="capitalize">${task.priority}</span></p>
                            ${task.completed ? `<p class="text-xs text-emerald-400 mt-1">Completed: ${formatDateForDisplay(getFormattedDate(task.timestamp))}</p>` : ''}
                        </div>
                        <div class="flex flex-col ml-3 space-y-2 flex-shrink-0">
                            <button onclick="deleteTask('${task.id}')" title="Delete Task" class="p-1 rounded-full text-red-400 hover:bg-white/10 transition-colors">
                                <i data-lucide="trash-2" class="w-5 h-5"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            window.createLucideIcons();
        }

        function addTask() {
            const text = D.taskInputNew.value.trim();
            const priority = D.taskPriority.value;
            const dueDate = D.taskDueDate.value;

            if (text === '') {
                showToast('Task description cannot be empty.', 'error');
                return;
            }

            const newTask = {
                id: Date.now().toString(),
                text: text,
                completed: false,
                priority: priority,
                dueDate: dueDate || null,
                timestamp: new Date().toISOString(),
            };

            state.tasks.unshift(newTask); // Add to the start
            D.taskInputNew.value = '';
            D.taskDueDate.value = '';
            D.taskPriority.value = 'medium';
            showToast('Task added!', 'success');
            saveState();
            renderTasks();
            calculateStats();
        }

        function toggleTaskCompletion(taskId) {
            const task = state.tasks.find(t => t.id === taskId);
            if (task) {
                task.completed = !task.completed;
                if (task.completed) {
                    showToast('Task completed! 🎉', 'success');
                } else {
                    showToast('Task marked incomplete.', 'info');
                }
                saveState();
                renderTasks();
                calculateStats();
                checkAchievements();
            }
        }

        function deleteTask(taskId) {
            state.tasks = state.tasks.filter(t => t.id !== taskId);
            showToast('Task deleted.', 'success');
            saveState();
            renderTasks();
            calculateStats();
        }

        // HISTORY/DETAILS MODAL
        function renderHistory(searchQuery = '', dateKey = '', limit = Infinity) {
            const allSessions = [...state.sessions];

            let filteredSessions = allSessions.filter(session => {
                const sessionDate = getFormattedDate(session.timestamp);
                const isDateMatch = !dateKey || sessionDate === dateKey;
                const isSearchMatch = !searchQuery || session.goal.toLowerCase().includes(searchQuery.toLowerCase()) || 
                                      session.mode.toLowerCase().includes(searchQuery.toLowerCase()) || 
                                      state.subjects.find(s => s.id === session.subjectId)?.name.toLowerCase().includes(searchQuery.toLowerCase());
                return isDateMatch && isSearchMatch;
            });

            D.historyList.innerHTML = ''; // Ensure the container is cleared first
            if (filteredSessions.length === 0) {
                D.noHistory.classList.remove('hidden');
                return;
            }
            D.noHistory.classList.add('hidden');

            // Apply limit for the main timer view (if not on history page)
            if (limit !== Infinity) {
                 filteredSessions = filteredSessions.slice(0, limit);
            }

            // The rest of the rendering logic remains the same:
            D.historyList.innerHTML = filteredSessions.map(session => {
                const subject = state.subjects.find(s => s.id === session.subjectId);
                const subjectName = subject ? subject.name : 'Unknown';
                const subjectColor = subject ? subject.color : 'gray';

                return `
                    <div onclick="openModal('${session.id}')" class="flex justify-between items-center p-3 bg-gray-700/50 rounded-lg cursor-pointer hover:bg-gray-700/70 transition-colors border-l-4 border-${subjectColor}-500">
                        <div class="flex-grow min-w-0">
                            <p class="text-sm font-medium text-gray-300 truncate">${session.goal || 'No goal set'}</p>
                            <p class="text-xs text-gray-400">
                                <span class="capitalize text-${subjectColor}-400">${subjectName}</span> | ${session.mode}
                            </p>
                        </div>
                        <p class="text-lg font-bold tabular-nums text-indigo-300 ml-4 flex-shrink-0">${formatTime(session.duration, false)}</p>
                    </div>
                `;
            }).join('');
            window.createLucideIcons();
        }

        function updateDateSelector() {
            const uniqueDates = [...new Set(state.sessions.map(s => getFormattedDate(s.timestamp)))].sort().reverse();
            D.dateSelector.innerHTML = '<option value="">All Dates</option>';
            D.dateSelector.innerHTML += uniqueDates.map(date => 
                `<option value="${date}">${formatDateForDisplay(date)}</option>`
            ).join('');

            // Apply event listeners for search input
            D.historySearch.oninput = () => handleDateChange(D.dateSelector.value || '');
        }

        function handleDateChange(dateKey) {
            const dailySessions = state.sessions.filter(s => {
                const isDateMatch = !dateKey || getFormattedDate(s.timestamp) === dateKey;
                const isSearchMatch = D.historySearch.value === '' || 
                                      s.goal.toLowerCase().includes(D.historySearch.value.toLowerCase()) || 
                                      s.mode.toLowerCase().includes(D.historySearch.value.toLowerCase()) || 
                                      state.subjects.find(sub => sub.id === s.subjectId)?.name.toLowerCase().includes(D.historySearch.value.toLowerCase());
                return isDateMatch && isSearchMatch;
            });
            const totalDuration = dailySessions.reduce((sum, s) => sum + s.duration, 0);

            const tasksCompletedToday = state.tasks.filter(t => t.completed && getFormattedDate(t.timestamp) === dateKey);
            const totalTasksCompletedToday = tasksCompletedToday.length;

            if (!dateKey) {
                D.dailySummaryContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">📅</div>
                        <p class="text-gray-400">Select a date to view your study summary</p>
                    </div>
                `;
            } else {
                 const completedTasksList = tasksCompletedToday.length > 0 ? tasksCompletedToday.map(t => `
                    <li class="text-sm text-gray-300 truncate">${t.text.replace(/\[Focus Session\]\s*/, '⏱️ ')}</li>
                `).join('') : '<li class="text-sm text-gray-400">No tasks completed on this day.</li>';
                
                // Group sessions by subject for the daily summary chart (existing logic kept)
                const subjectData = dailySessions.reduce((acc, s) => {
                    const subject = state.subjects.find(sub => sub.id === s.subjectId);
                    const subjectName = subject ? subject.name : 'Unknown';
                    if (!acc[subjectName]) {
                        acc[subjectName] = 0;
                    }
                    acc[subjectName] += s.duration;
                    return acc;
                }, {});

                const subjectBreakdownList = Object.entries(subjectData).sort(([, a], [, b]) => b - a).map(([name, duration]) => {
                    const subject = state.subjects.find(s => s.name === name);
                    const colorClass = subject ? `text-${subject.color}-400` : 'text-gray-400';
                    return `<li class="flex justify-between text-sm text-gray-300"><span class="${colorClass}">${name}</span><span>${formatMinutes(duration)}</span></li>`;
                }).join('');

                const dailySummaryHTML = `
                    <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50 mb-6">
                        <h3 class="text-xl font-bold text-gray-100 mb-2">Summary for ${formatDateForDisplay(dateKey)}</h3>
                        <div class="grid grid-cols-2 gap-4">
                            <div class="p-3 bg-gray-800 rounded-lg">
                                <p class="text-sm text-gray-400">Total Focus Time</p>
                                <p class="text-2xl font-extrabold text-indigo-400">${formatMinutes(totalDuration)}</p>
                            </div>
                            <div class="p-3 bg-gray-800 rounded-lg">
                                <p class="text-sm text-gray-400">Tasks Completed</p>
                                <p class="text-2xl font-extrabold text-emerald-400">${totalTasksCompletedToday}</p>
                            </div>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                        <div class="glass-base p-4 rounded-xl bg-gray-800/50 border-gray-700/50">
                            <h3 class="text-lg font-semibold text-emerald-300 mb-3 flex items-center">
                                <i data-lucide="clipboard-check" class="w-5 h-5 mr-2"></i> Tasks Completed Today (${tasksCompletedToday.length})
                            </h3>
                            <ul class="space-y-2 max-h-48 overflow-y-auto pr-2">
                                ${completedTasksList}
                            </ul>
                        </div>
                        <div class="glass-base p-4 rounded-xl bg-gray-800/50 border-gray-700/50">
                            <h3 class="text-lg font-semibold text-indigo-300 mb-3 flex items-center">
                                <i data-lucide="book" class="w-5 h-5 mr-2"></i> Time by Subject
                            </h3>
                            <ul class="space-y-2 max-h-48 overflow-y-auto pr-2">
                                ${subjectBreakdownList}
                            </ul>
                        </div>
                    </div>
                `;
                D.dailySummaryContainer.innerHTML = dailySummaryHTML;
                window.createLucideIcons();
            }

            // Render the full session list for the selected date/search term
            renderHistory(D.historySearch.value, dateKey, Infinity);
        }

        function openModal(sessionId) {
            currentSessionId = sessionId;
            const session = state.sessions.find(s => s.id === sessionId);
            if (!session) return;
            
            const subject = state.subjects.find(s => s.id === session.subjectId);
            const subjectName = subject ? subject.name : 'Unknown Subject';

            const modalContent = `
                <p class="mb-2 text-lg font-bold">${session.goal || 'No goal set'}</p>
                <p class="mb-1"><strong>Date:</strong> ${formatDateForDisplay(getFormattedDate(session.timestamp))}</p>
                <p class="mb-1"><strong>Duration:</strong> <span class="text-indigo-400 font-bold">${formatTime(session.duration, false)}</span></p>
                <p class="mb-1"><strong>Subject:</strong> <span class="capitalize">${subjectName}</span></p>
                <p class="mb-1"><strong>Mode:</strong> ${session.mode}</p>
            `;
            
            D.modalContent.innerHTML = modalContent;
            D.detailsModal.classList.remove('hidden');
            document.body.classList.add('modal-open');
            window.createLucideIcons();
        }

        function closeModal() {
            D.detailsModal.classList.add('hidden');
            document.body.classList.remove('modal-open');
            currentSessionId = null;
        }

        function deleteSession(sessionId) {
            if (confirm("Are you sure you want to permanently delete this session?")) {
                state.sessions = state.sessions.filter(s => s.id !== sessionId);
                
                // Also remove the associated task if it exists (prefixed with 's')
                state.tasks = state.tasks.filter(t => t.id !== ('s' + sessionId));
                
                showToast('Session and associated task deleted.', 'success');
                calculateStats();
                checkStreakOnLoad(); // Re-check streak to correct dailyTimeLogged
                updateUI();
                closeModal();
                // Re-render history view if on that page
                if (state.currentPage === 'history') {
                    updateDateSelector();
                    handleDateChange(D.dateSelector.value || '');
                }
            }
        }

        // STATS & PROGRESS
        function calculateStats() {
            const now = new Date();
            const startOfWeek = getPeriodStart('week', now);
            const startOfPrevWeek = getPeriodStart('prevWeek', now);
            const startOfMonth = getPeriodStart('month', now);
            const startOfPrevMonth = getPeriodStart('prevMonth', now);

            // Time filtering
            const allTime = state.sessions.filter(s => s.mode.includes('Focus') || s.mode.includes('Free Mode'));
            const sessionsCount = allTime.length;

            const weeklyTimeSessions = allTime.filter(s => new Date(s.timestamp) >= startOfWeek);
            const monthlyTimeSessions = allTime.filter(s => new Date(s.timestamp) >= startOfMonth);
            const prevWeeklyTimeSessions = allTime.filter(s => new Date(s.timestamp) >= startOfPrevWeek && new Date(s.timestamp) < startOfWeek);
            const prevMonthlyTimeSessions = allTime.filter(s => new Date(s.timestamp) >= startOfPrevMonth && new Date(s.timestamp) < startOfMonth);

            const overallTime = allTime.reduce((sum, s) => sum + s.duration, 0);
            const weeklyTime = weeklyTimeSessions.reduce((sum, s) => sum + s.duration, 0);
            const monthlyTime = monthlyTimeSessions.reduce((sum, s) => sum + s.duration, 0);
            const prevWeeklyTime = prevWeeklyTimeSessions.reduce((sum, s) => sum + s.duration, 0);
            const prevMonthlyTime = prevMonthlyTimeSessions.reduce((sum, s) => sum + s.duration, 0);

            // Weekly Breakdown
            const dailyTimeInWeek = Array(7).fill(0);
            weeklyTimeSessions.forEach(s => {
                const dayIndex = (new Date(s.timestamp).getDay() || 7) - 1; // 0=Mon, 6=Sun
                dailyTimeInWeek[dayIndex] += s.duration;
            });

            // Subject Breakdown
            const subjectBreakdown = {};
            allTime.forEach(session => {
                const duration = session.duration;
                const subjectName = state.subjects.find(s => s.id === session.subjectId)?.name || 'Unknown';
                subjectBreakdown[subjectName] = (subjectBreakdown[subjectName] || 0) + duration;
            });

            // Tasks Stats
            const tasksCompleted = state.tasks.filter(t => t.completed).length;
            const totalTasks = state.tasks.length;
            const efficiency = totalTasks > 0 ? Math.round((tasksCompleted / totalTasks) * 100) : 0;

            // Time Stats
            // FIX: Ensure safe access to the oldest session's timestamp
            const firstSessionTimestamp = state.sessions.length > 0 
                ? state.sessions[state.sessions.length - 1].timestamp 
                : new Date().toISOString();
                
            const totalDays = Math.ceil((Date.now() - new Date(firstSessionTimestamp).getTime()) / (1000 * 3600 * 24)) || 1;
            
            const avgDailyHours = (overallTime / totalDays) / 3600;
            const avgSessionLengthSeconds = sessionsCount > 0 ? overallTime / sessionsCount : 0;

            // Most Focused Subject
            const mostFocused = Object.entries(subjectBreakdown).sort(([, a], [, b]) => b - a)[0];
            // FIX: Use ternary operator to safely handle cases where mostFocused is undefined (no sessions logged)
            const mostFocusedSubject = mostFocused ? mostFocused[0] : 'N/A';
            const mostFocusedSubjectRatio = overallTime > 0 && mostFocused ? mostFocused[1] / overallTime : 0;

            stats = {
                overallTime,
                monthlyTime,
                weeklyTime,
                prevMonthlyTime,
                prevWeeklyTime,
                dailyTimeInWeek,
                tasksCompleted,
                totalTasks,
                efficiency,
                avgDailyHours,
                avgSessionLengthSeconds,
                subjectBreakdown,
                mostFocusedSubject,
                mostFocusedSubjectRatio
            };
        }

        function renderProgress() {
            calculateStats(); // Recalculate just in case

            // 1. Metrics Cards
            D.metricsContainer.innerHTML = `
                <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50">
                    <p class="text-sm text-gray-400">Total Focus</p>
                    <p class="text-2xl font-extrabold text-indigo-400">${formatMinutes(stats.overallTime)}</p>
                    <p class="text-xs text-gray-500">${state.sessions.length} sessions</p>
                </div>
                <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50">
                    <p class="text-sm text-gray-400">Weekly Focus</p>
                    <p class="text-2xl font-extrabold text-indigo-400">${formatMinutes(stats.weeklyTime)}</p>
                    <p class="text-xs text-gray-500">${formatComparison(stats.weeklyTime, stats.prevWeeklyTime, 'week')}</p>
                </div>
                <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50">
                    <p class="text-sm text-gray-400">Monthly Focus</p>
                    <p class="text-2xl font-extrabold text-indigo-400">${formatMinutes(stats.monthlyTime)}</p>
                    <p class="text-xs text-gray-500">${formatComparison(stats.monthlyTime, stats.prevMonthlyTime, 'month')}</p>
                </div>
                <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50">
                    <p class="text-sm text-gray-400">Task Completion</p>
                    <p class="text-2xl font-extrabold text-emerald-400">${stats.efficiency}%</p>
                    <p class="text-xs text-gray-500">${stats.tasksCompleted} / ${stats.totalTasks} completed</p>
                </div>
                <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50">
                    <p class="text-sm text-gray-400">Longest Streak</p>
                    <p class="text-2xl font-extrabold text-red-400">${stats.longestDailyStreak || state.longestDailyStreak} days</p>
                    <p class="text-xs text-gray-500">Current: ${state.currentDailyStreak} days</p>
                </div>
                <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50">
                    <p class="text-sm text-gray-400">Avg. Session Length</p>
                    <p class="text-2xl font-extrabold text-yellow-400">${formatMinutes(stats.avgSessionLengthSeconds)}</p>
                    <p class="text-xs text-gray-500">Avg. Daily: ${stats.avgDailyHours.toFixed(1)} hrs</p>
                </div>
            `;
            window.createLucideIcons(); // Update icons in comparison metrics

            // 2. Weekly Focus Chart
            renderWeeklyChart();

            // 3. Subject Distribution Chart
            renderSubjectChart();
        }

        function getSubjectColor(subjectName) {
            const subject = state.subjects.find(s => s.name === subjectName);
            if (subject) {
                return `hsl(${SUBJECT_COLORS.indexOf(subject.color) * 360 / SUBJECT_COLORS.length}, 70%, 50%)`;
            }
            return '#6b7280'; // gray fallback
        }

        function renderWeeklyChart() {
            if (weeklyChart) weeklyChart.destroy();
            
            const labels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            const data = stats.dailyTimeInWeek.map(s => Math.floor(s / 3600)); // Convert to Hours

            weeklyChart = new Chart(D.weeklyChart, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Focus Hours',
                        data: data,
                        backgroundColor: '#4f46e5',
                        borderColor: '#6366f1',
                        borderWidth: 1,
                        borderRadius: 5,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Hours',
                                color: '#9ca3af'
                            },
                            grid: { color: '#374151' },
                            ticks: { color: '#d1d5db' }
                        },
                        x: {
                            grid: { display: false },
                            ticks: { color: '#d1d5db' }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y} hours`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderSubjectChart() {
            if (subjectChart) subjectChart.destroy();

            const subjectNames = Object.keys(stats.subjectBreakdown);
            const dataValues = Object.values(stats.subjectBreakdown);
            const colors = subjectNames.map(name => getSubjectColor(name));
            
            subjectChart = new Chart(D.subjectChart, {
                type: 'doughnut',
                data: {
                    labels: subjectNames,
                    datasets: [{
                        label: 'Focus Time (Seconds)',
                        data: dataValues,
                        backgroundColor: colors,
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: '#d1d5db'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const value = context.parsed;
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    return `${context.label}: ${formatMinutes(value)} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // ACHIEVEMENTS
        function checkAchievements() {
            ACHIEVEMENTS_CONFIG.forEach(ach => {
                let currentProgress = 0;
                if (ach.unit === 'minutes') {
                    currentProgress = Math.floor(stats.overallTime / 60);
                } else if (ach.unit === 'tasks') {
                    currentProgress = stats.tasksCompleted;
                }

                if (currentProgress >= ach.goal && !state.unlockedAchievements.includes(ach.id)) {
                    state.unlockedAchievements.push(ach.id);
                    showToast(`🏆 Achievement Unlocked: ${ach.name}!`, 'success');
                    saveState();
                }
            });
        }

        function renderAchievements() {
            const currentTotalMinutes = Math.floor(stats.overallTime / 60);
            const currentTotalTasks = stats.tasksCompleted;

            D.trophiesContainer.innerHTML = ACHIEVEMENTS_CONFIG.map(ach => {
                const isUnlocked = state.unlockedAchievements.includes(ach.id);
                let currentProgress = ach.unit === 'minutes' ? currentTotalMinutes : currentTotalTasks;
                let progress = Math.min(100, (currentProgress / ach.goal) * 100);
                
                const statusText = isUnlocked ? 'Unlocked!' : `${progress.toFixed(0)}% Complete`;
                const progressClass = isUnlocked ? 'bg-emerald-500' : 'bg-indigo-500';
                const containerClass = isUnlocked ? 'border-emerald-500/50 shadow-emerald-500/30' : 'border-gray-500/50 shadow-indigo-500/30';
                const iconClass = isUnlocked ? 'text-emerald-400 achievement-pulse' : 'text-gray-400';

                return `
                    <div class="glass-base p-5 rounded-2xl shadow-xl border ${containerClass} bg-gray-800/50">
                        <div class="flex items-start">
                            <i data-lucide="${ach.icon}" class="w-8 h-8 mr-4 ${iconClass}"></i>
                            <div class="flex-grow">
                                <h3 class="text-xl font-bold ${ach.color}">${ach.name}</h3>
                                <p class="text-sm text-gray-400">${ach.description}</p>
                                <p class="text-xs text-gray-500 mt-1">Goal: ${ach.goal} ${ach.unit}</p>
                            </div>
                        </div>
                        <div class="mt-4">
                            <div class="flex justify-between text-xs font-medium mb-1">
                                <span class="text-gray-300">${statusText}</span>
                                <span class="text-gray-400">${isUnlocked ? '' : `(${currentProgress} / ${ach.goal})`}</span>
                            </div>
                            <div class="w-full bg-gray-700 rounded-full h-2.5">
                                <div class="${progressClass} h-2.5 rounded-full" style="width: ${progress}%"></div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            window.createLucideIcons();
        }

        // SETTINGS
        function updateDailyGoal(newGoal) {
            const goal = parseInt(newGoal);
            if (goal < 5) {
                showToast('Goal must be at least 5 minutes.', 'error');
                D.dailyGoalInput.value = state.dailyFocusGoalMinutes; // Revert
                return;
            }
            state.dailyFocusGoalMinutes = goal;
            showToast(`Daily focus goal set to ${goal} minutes.`, 'success');
            saveState();
            updateUI(); // Update streak progress bar
        }

        // DATA MANAGEMENT
        function exportData() {
            const data = {
                state: state,
                stats: stats,
                timestamp: new Date().toISOString()
            };
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `study_tracker_data_${getFormattedDate(data.timestamp)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('Data export initiated.', 'success');
        }
        
        function exportCsvData() {
             const sessions = state.sessions;
            if (sessions.length === 0) {
                showToast('No sessions to export.', 'error');
                return;
            }
            
            const headers = ["ID", "Date", "Time (seconds)", "Time (minutes)", "Subject", "Goal", "Mode"];
            
            const rows = sessions.map(session => {
                const subjectName = state.subjects.find(s => s.id === session.subjectId)?.name || 'Unknown';
                return [
                    session.id,
                    formatDateForDisplay(getFormattedDate(session.timestamp)),
                    session.duration,
                    (session.duration / 60).toFixed(2),
                    subjectName,
                    `"${session.goal.replace(/"/g, '""')}"`, // Handle quotes in goals
                    session.mode
                ];
            });

            let csvContent = headers.join(",") + "\n";
            rows.forEach(row => {
                csvContent += row.join(",") + "\n";
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `study_tracker_sessions_${getFormattedDate(new Date().toISOString())}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('CSV export initiated.', 'success');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (importedData.state) {
                        // Merge the imported state into the current state
                        state = { ...state, ...importedData.state };
                        
                        // Sanity check: ensure array properties are arrays and not null
                        if (!Array.isArray(state.subjects)) state.subjects = DEFAULT_SUBJECTS;
                        if (!Array.isArray(state.sessions)) state.sessions = [];
                        if (!Array.isArray(state.tasks)) state.tasks = [];
                        if (!Array.isArray(state.unlockedAchievements)) state.unlockedAchievements = [];
                        
                        // Recalculate everything after a full import
                        loadState(); 
                        showToast('Data imported successfully! Please check your history and settings.', 'success');
                        switchPage(state.currentPage || 'timer');
                    } else {
                        showToast('Invalid file format. Please import a valid Study Tracker JSON file.', 'error');
                    }
                } catch (error) {
                    showToast('Error reading file: Invalid JSON format.', 'error');
                }
            };
            reader.readAsText(file);
        }

        function clearAllData() {
            if (confirm("WARNING: This will permanently delete ALL your sessions, tasks, and settings. Are you absolutely sure you want to continue?")) {
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                state = { ...DEFAULT_STATE }; // Re-initialize state to default values
                loadState();
                switchPage('timer');
                showToast('All application data cleared successfully.', 'success');
            }
        }

        // MUSIC PLAYER
        function initMusicPlayer() {
            D.musicPlayer.src = PLAYLIST[currentSongIndex];
            D.musicPlayer.loop = false;
            D.musicPlayer.volume = 0.5;
            D.musicPlayer.onended = () => {
                currentSongIndex = (currentSongIndex + 1) % PLAYLIST.length;
                D.musicPlayer.src = PLAYLIST[currentSongIndex];
                D.musicPlayer.play().catch(e => console.log('Autoplay failed:', e));
                updateUI();
            };
        }

        function toggleSongPlayback() {
            if (D.musicPlayer.paused) {
                // To play the audio, the user must have initiated a gesture first (which clicking this button is).
                D.musicPlayer.play().catch(e => {
                    showToast('Autoplay blocked. Please try clicking the button again after interacting with the page.', 'error');
                    console.error('Audio playback failed:', e);
                });
            } else {
                D.musicPlayer.pause();
            }
            updateUI(); // To update the music button icon
        }

        // PAGE NAVIGATION
        function switchPage(page) {
            const views = {
                'timer': D.timerView,
                'tasks': D.tasksView,
                'history': D.historyView,
                'achievements': D.achievementsView,
                'progress': D.progressView,
                'settings': D.settingsView
            };

            const navButtons = {
                'timer': D.navTimerBtn,
                'tasks': D.navTasksBtn,
                'history': D.navHistoryBtn,
                'achievements': D.navAchievementsBtn,
                'progress': D.navProgressBtn,
                'settings': D.navSettingsBtn
            };

            // Hide all views
            Object.values(views).forEach(view => view.classList.add('hidden'));

            // Show selected view
            const selectedView = views[page];
            if (selectedView) {
                selectedView.classList.remove('hidden');
                state.currentPage = page;
            }

            // Update navigation button styles
            Object.values(navButtons).forEach(btn => {
                btn.classList.remove('bg-indigo-600');
                btn.classList.add('bg-gray-700/50', 'hover:bg-gray-700');
            });

            const selectedBtn = navButtons[page];
            if (selectedBtn) {
                selectedBtn.classList.remove('bg-gray-700/50', 'hover:bg-gray-700');
                selectedBtn.classList.add('bg-indigo-600');
            }

            // Run view-specific rendering
            if (page === 'tasks') renderTasks();
            if (page === 'history') {
                updateDateSelector();
                handleDateChange(D.dateSelector.value || '');
            }
            if (page === 'achievements') renderAchievements();
            if (page === 'progress') renderProgress();
            if (page === 'settings') renderSubjectManager();

            window.createLucideIcons(); // Re-render icons after DOM changes
            saveState();
        }

        function toggleFullscreenClock() {
            const isHidden = D.fullscreenClockModal.classList.contains('hidden');
            if (isHidden) {
                D.fullscreenClockModal.classList.remove('hidden');
                document.body.classList.add('modal-open');
                D.fullscreenBtn.querySelector('i').setAttribute('data-lucide', 'minimize');
            } else {
                D.fullscreenClockModal.classList.add('hidden');
                document.body.classList.remove('modal-open');
                D.fullscreenBtn.querySelector('i').setAttribute('data-lucide', 'maximize');
            }
            window.createLucideIcons();
        }

// --- KEYBOARD SHORTCUTS ---
document.addEventListener('keydown', (e) => {
    // Only respond to shortcuts if no input or textarea is focused
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
    }

    // Timer View Shortcuts
    if (state.currentPage === 'timer') {
        // Space: Start/Pause
        if (e.key === ' ' || e.key.toLowerCase() === 'p') {
            e.preventDefault();
            startPauseHandler();
        }

        // S: Stop Session
        const getRemaining = getRemainingTime();
        if (e.key.toLowerCase() === 's' && (state.isRunning || getRemaining > 0)) {
            e.preventDefault();
            stopSession();
        }

        // D: Discard Session (only if paused with time > 0 or in pomodoro break)
        if (e.key.toLowerCase() === 'd' && !state.isRunning && getRemaining > 0) {
            e.preventDefault();
            discardSession();
        }

        // F: Toggle Fullscreen
        if (e.key.toLowerCase() === 'f') {
            e.preventDefault();
            toggleFullscreenClock();
        }
    }
    
    // --- Global Shortcuts ---
    // Close Modal - Esc
    if (e.key === 'Escape') {
        if (!D.fullscreenClockModal.classList.contains('hidden')) {
            toggleFullscreenClock();
        } else if (!D.detailsModal.classList.contains('hidden')) {
            closeModal();
        }
    }
});

// --- Browser Focus/Blur and Throttling Correction ---
document.addEventListener('visibilitychange', () => {
    // If the document is now visible AND the timer is running, perform an instant update.
    if (document.visibilityState === 'visible' && state.isRunning) {
        // Calling updateTimer immediately calculates the time drift 
        // that occurred while the tab was hidden and corrects the timer state.
        updateTimer();
    }
});

       // INITIALIZATION
        document.addEventListener('DOMContentLoaded', () => {
            loadState();
            
           
            filterExpiredTasks(); 
        
            
            initMusicPlayer();
            setTimerMode(state.timerMode); // Re-set mode on load to ensure pomodoroTimeRemaining is correct
            renderSubjectSelector();
            D.dailyGoalInput.value = state.dailyFocusGoalMinutes;
            updateUI(); // Final UI update
            
            // Re-create icons on load
            window.createLucideIcons();
            switchPage(state.currentPage || 'timer');
        });
    </script>
</body>
</html>