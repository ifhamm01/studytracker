<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script>
        window.createLucideIcons = () => {
            if (window.lucide && window.lucide.createIcons) {
                window.lucide.createIcons();
            }
        };
    </script>
    
    <meta name="theme-color" content="#4f46e5">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“š</text></svg>">
    
   <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
        }
        
        .glass-base {
            backdrop-filter: blur(16px);
            border: 1px solid rgba(126, 87, 87, 0.1);
            transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        
        .glass-base:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.15), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
        }

        .subject-radio:checked + label {
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%);
            border-color: #a5b4fc;
            color: #fff;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.6);
            transform: scale(1.05);
        }
        
        .subject-radio + label {
            transition: all 0.2s ease;
        }
        
        input[type="checkbox"] {
            appearance: none;
            height: 1.25rem;
            width: 1.25rem;
            border: 2px solid #6b7280;
            border-radius: 0.25rem;
            background-color: transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="checkbox"]:checked {
            background-color: #4f46e5;
            border-color: #4f46e5;
        }
        
        input[type="checkbox"]:checked::after {
            content: 'âœ“';
            display: block;
            color: white;
            font-size: 0.75rem;
            text-align: center;
            line-height: 1.1;
        }
        
        body.modal-open {
            overflow: hidden;
        }
        
        .empty-state {
            padding: 3rem 1rem;
            text-align: center;
        }
        
        .empty-state-icon {
            font-size: 4rem;
            opacity: 0.3;
            margin-bottom: 1rem;
        }
        
        .achievement-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
        
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
            z-index: 100;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .priority-high { border-left: 4px solid #ef4444; }
        .priority-medium { border-left: 4px solid #f59e0b; }
        .priority-low { border-left: 4px solid #10b981; }
        
        @media (max-width: 768px) {
            #fullscreen-time-display { font-size: 8rem; }
        }
        @media (max-width: 480px) {
            #fullscreen-time-display { font-size: 6rem; }
        }
    </style>
</head>
<body class="text-white min-h-screen">
    <div class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-6 sm:mb-8">
            <h1 class="text-3xl font-extrabold text-indigo-400">Study Tracker Pro</h1>
            <p class="text-gray-400 text-sm mt-2">Your productivity companion</p>
        </header>

        <nav class="flex space-x-2 mb-6 p-1 bg-gray-800 rounded-full overflow-x-auto">
            <button id="nav-timer-btn" onclick="switchPage('timer')" class="flex-1 py-2 px-3 sm:px-4 rounded-full text-xs sm:text-sm font-semibold transition-colors whitespace-nowrap bg-indigo-600">
                <i data-lucide="clock" class="w-4 h-4 inline mr-1"></i> Timer
            </button>
            <button id="nav-tasks-btn" onclick="switchPage('tasks')" class="flex-1 py-2 px-3 sm:px-4 rounded-full text-xs sm:text-sm font-semibold transition-colors whitespace-nowrap bg-gray-700/50 hover:bg-gray-700">
                <i data-lucide="list-todo" class="w-4 h-4 inline mr-1"></i> Tasks
            </button>
            <button id="nav-history-btn" onclick="switchPage('history')" class="flex-1 py-2 px-3 sm:px-4 rounded-full text-xs sm:text-sm font-semibold transition-colors whitespace-nowrap bg-gray-700/50 hover:bg-gray-700">
                <i data-lucide="calendar" class="w-4 h-4 inline mr-1"></i> History
            </button>
            <button id="nav-achievements-btn" onclick="switchPage('achievements')" class="flex-1 py-2 px-3 sm:px-4 rounded-full text-xs sm:text-sm font-semibold transition-colors whitespace-nowrap bg-gray-700/50 hover:bg-gray-700">
                <i data-lucide="medal" class="w-4 h-4 inline mr-1"></i> Achievements
            </button>
            <button id="nav-progress-btn" onclick="switchPage('progress')" class="flex-1 py-2 px-3 sm:px-4 rounded-full text-xs sm:text-sm font-semibold transition-colors whitespace-nowrap bg-gray-700/50 hover:bg-gray-700">
                <i data-lucide="trending-up" class="w-4 h-4 inline mr-1"></i> Progress
            </button>
            <button id="nav-settings-btn" onclick="switchPage('settings')" class="flex-1 py-2 px-3 sm:px-4 rounded-full text-xs sm:text-sm font-semibold transition-colors whitespace-nowrap bg-gray-700/50 hover:bg-gray-700">
                <i data-lucide="settings" class="w-4 h-4 inline mr-1"></i> Settings
            </button>
        </nav>

        <main class="glass-base rounded-3xl p-5 sm:p-6 lg:p-8 shadow-2xl bg-gray-900/40">
            <div id="timer-view">
                <div id="timer-card" class="glass-base p-6 rounded-3xl shadow-2xl mb-8 bg-gray-800/30 border-gray-500/50">
                    <div class="flex justify-between items-center mb-4">
                        <h1 id="timer-title" class="text-2xl font-bold text-indigo-300">Focused Subject Tracker</h1>
                        <button id="music-btn" onclick="toggleSongPlayback()" class="p-2 rounded-full text-gray-400 hover:bg-white/10 transition-colors">
                            <i data-lucide="music" class="w-6 h-6"></i>
                        </button>
                    </div>
                    
                    <div class="text-center mb-6">
                        <p id="time-display" class="text-7xl lg:text-8xl font-extrabold tabular-nums tracking-tighter">00:00:00</p>
                    </div>
                    
                    <div class="mb-8 flex flex-col sm:flex-row justify-center items-center sm:space-x-6 space-y-4 sm:space-y-0 py-2">
                        <div class="relative w-24 h-24 flex-shrink-0">
                            <svg class="w-full h-full transform -rotate-90" viewBox="0 0 70 70">
                                <circle class="text-gray-700/50" stroke-width="6" stroke="currentColor" fill="transparent" r="30" cx="35" cy="35"></circle>
                                <circle id="streak-progress-bar" class="text-emerald-400 transition-all duration-700 ease-out" stroke-width="6" stroke="currentColor" stroke-linecap="round" fill="transparent" r="30" cx="35" cy="35" style="stroke-dasharray: 188.5; stroke-dashoffset: 188.5;"></circle>
                            </svg>
                            <span id="streak-progress-percent" class="absolute inset-0 flex items-center justify-center text-sm font-bold text-gray-300">0%</span>
                        </div>
                        <div class="flex-grow text-center sm:text-left">
                            <div class="text-sm text-gray-400 mb-1">Current Daily Focus Streak</div>
                            <div class="flex items-center justify-center sm:justify-start">
                                <i data-lucide="flame" class="w-8 h-8 mr-3 text-red-400"></i>
                                <span id="streak-count" class="text-5xl font-extrabold text-red-300 tabular-nums">0</span>
                            </div>
                            <div id="next-streak-info" class="text-xs text-gray-500 mt-2"></div>
                        </div>
                    </div>

                    <div class="mb-6">
                        <label class="block text-sm font-medium mb-2 text-gray-300">Select Subject</label>
                        <div id="subject-selector" class="flex flex-wrap gap-2"></div>
                    </div>

                    <div class="mb-8">
                        <label for="task-input" class="block text-sm font-medium mb-2 text-gray-300">Session Goal</label>
                        <div class="flex items-center bg-white/10 rounded-full p-3">
                            <i data-lucide="target" class="w-5 h-5 mr-3 text-indigo-400 flex-shrink-0"></i>
                            <input id="task-input" type="text" maxlength="100" placeholder="What do you want to accomplish?" class="w-full bg-transparent text-white placeholder-gray-400 focus:outline-none">
                        </div>
                    </div>
                    
                    <div class="mb-8">
                        <label class="block text-sm font-medium mb-2 text-gray-300">Select Timer Mode</label>
                        <div id="preset-selector" class="flex space-x-3 justify-center flex-wrap gap-2">
                            <button id="preset-free-btn" onclick="setTimerMode('free')" class="flex-1 p-3 rounded-lg font-semibold transition-colors bg-indigo-600/70 hover:bg-indigo-600 border border-transparent min-w-[120px]">
                                <i data-lucide="sun" class="w-5 h-5 inline mr-1"></i> Free Mode
                            </button>
                            <button id="preset-25-5-btn" onclick="setTimerMode('25/5')" class="flex-1 p-3 rounded-lg font-semibold transition-colors bg-gray-700/50 hover:bg-gray-600/70 border border-transparent min-w-[120px]">
                                <i data-lucide="timer" class="w-5 h-5 inline mr-1"></i> 25/5 Pomodoro
                            </button>
                            <button id="preset-50-10-btn" onclick="setTimerMode('50/10')" class="flex-1 p-3 rounded-lg font-semibold transition-colors bg-gray-700/50 hover:bg-gray-600/70 border border-transparent min-w-[120px]">
                                <i data-lucide="clock" class="w-5 h-5 inline mr-1"></i> 50/10 Focus
                            </button>
                        </div>
                    </div>

                    <div class="flex justify-center space-x-4 flex-wrap gap-2">
                        <button id="start-pause-btn" onclick="startPauseHandler()" class="p-4 rounded-full shadow-2xl transition-all transform hover:scale-105 active:scale-95 bg-green-500 hover:bg-green-600">
                            <i data-lucide="play" class="w-6 h-6"></i>
                        </button>
                        <button id="stop-btn" onclick="stopSession()" disabled class="p-4 rounded-full bg-red-600/70 hover:bg-red-600 shadow-2xl transition-all transform hover:scale-105 active:scale-95">
                            <i data-lucide="square" class="w-6 h-6"></i>
                        </button>
                        <button id="discard-btn" onclick="discardSession()" disabled class="p-4 rounded-full bg-gray-700/50 hover:bg-gray-600/70 shadow-2xl transition-all transform hover:scale-105 active:scale-95">
                            <i data-lucide="x-circle" class="w-6 h-6"></i>
                        </button>
                        <button id="fullscreen-btn" onclick="toggleFullscreenClock()" class="p-4 rounded-full bg-indigo-600/70 hover:bg-indigo-600 shadow-2xl transition-all transform hover:scale-105 active:scale-95">
                            <i data-lucide="maximize" class="w-6 h-6"></i>
                        </button>
                    </div>
                </div>

                <div class="glass-base mt-8 p-4 rounded-3xl shadow-xl bg-gray-800/50 border-gray-700/50">
                    <h2 class="text-xl font-semibold mb-3 text-center text-gray-300 flex items-center justify-center">
                        <i data-lucide="history" class="w-5 h-5 mr-2 text-gray-400"></i>
                        Recent Focus Sessions
                    </h2>
                    <div id="history-list" class="max-h-48 overflow-y-auto space-y-2"></div>
                    <div id="no-history" class="empty-state hidden">
                        <div class="empty-state-icon">ðŸ“š</div>
                        <p class="text-gray-400">No sessions yet. Start your first focus session!</p>
                    </div>
                </div>
            </div>
            
            <div id="tasks-view" class="hidden">
                <div class="glass-base p-6 rounded-3xl shadow-2xl mb-8 bg-gray-800/30 border-gray-500/50">
                    <h1 class="text-2xl font-bold text-indigo-300 mb-4">Task List</h1>
                    
                    <div class="mb-6 space-y-3">
                        <div class="flex space-x-3">
                            <div class="flex items-center bg-white/10 rounded-full p-3 flex-grow">
                                <i data-lucide="plus-circle" class="w-5 h-5 mr-3 text-emerald-400 flex-shrink-0"></i>
                                <input id="new-task-input" type="text" maxlength="200" placeholder="Add a new task..." class="w-full bg-transparent text-white placeholder-gray-400 focus:outline-none" onkeypress="if(event.key === 'Enter') addTask()">
                            </div>
                            <button onclick="addTask()" class="p-3 rounded-full bg-emerald-600 hover:bg-emerald-700 transition-colors flex-shrink-0">
                                <i data-lucide="send" class="w-6 h-6"></i>
                            </button>
                        </div>
                        
                        <div class="flex space-x-2">
                            <select id="task-priority" class="p-2 rounded-lg bg-gray-700 border border-gray-600 text-white text-sm flex-shrink-0">
                                <option value="low">Low Priority</option>
                                <option value="medium" selected>Medium Priority</option>
                                <option value="high">High Priority</option>
                            </select>
                            <input id="task-due-date" type="date" class="p-2 rounded-lg bg-gray-700 border border-gray-600 text-white text-sm flex-grow">
                        </div>
                    </div>

                    <div id="tasks-list" class="space-y-3 max-h-96 overflow-y-auto"></div>
                    <div id="no-tasks" class="empty-state hidden">
                        <div class="empty-state-icon">âœ…</div>
                        <p class="text-gray-400">No tasks yet. Add your first task above!</p>
                    </div>
                </div>
            </div>
            
            <div id="history-view" class="hidden">
                <div class="glass-base p-6 rounded-3xl shadow-2xl mb-8 bg-gray-800/30 border-gray-500/50">
                    <div class="flex justify-between items-start mb-4 flex-wrap gap-3">
                        <h1 class="text-2xl font-bold text-indigo-300">Daily Focus History</h1>
                        <div class="flex space-x-2 flex-wrap">
                            <button onclick="exportData()" class="p-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 transition-colors text-sm flex items-center">
                                <i data-lucide="download" class="w-4 h-4 mr-2"></i>
                                Export JSON
                            </button>
                            <button onclick="exportCsvData()" class="p-2 rounded-lg bg-emerald-600 hover:bg-emerald-700 transition-colors text-sm flex items-center">
                                <i data-lucide="download" class="w-4 h-4 mr-2"></i>
                                Export CSV
                            </button>
                        </div>
                    </div>
                    
                    <div class="mb-6 flex space-x-3">
                        <input id="history-search" type="text" placeholder="Search sessions..." class="flex-grow p-3 rounded-lg bg-gray-700 border border-gray-600 text-white placeholder-gray-400 focus:ring-indigo-500 focus:border-indigo-500">
                        <select id="date-selector" onchange="handleDateChange(this.value)" class="p-3 rounded-lg bg-gray-700 border-gray-600 text-white focus:ring-indigo-500 focus:border-indigo-500 flex-shrink-0">
                            <option value="">Select Date</option>
                        </select>
                    </div>

                    <div id="daily-summary-container" class="space-y-6">
                        <div class="empty-state">
                            <div class="empty-state-icon">ðŸ“…</div>
                            <p class="text-gray-400">Select a date to view your study summary</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="achievements-view" class="hidden">
                <div class="glass-base p-6 rounded-3xl shadow-2xl mb-8 bg-gray-800/30 border-gray-500/50">
                    <h1 class="text-2xl font-bold text-emerald-300 mb-6">Trophy Case</h1>
                    <p class="text-gray-400 mb-6">Earn achievements by hitting focus and task milestones.</p>
                    <div id="trophies-container" class="grid grid-cols-1 md:grid-cols-2 gap-6"></div>
                </div>
            </div>
            
            <div id="progress-view" class="hidden">
                <div class="glass-base p-6 rounded-3xl shadow-2xl mb-8 bg-gray-800/30 border-gray-500/50">
                    <h1 class="text-2xl font-bold text-indigo-300 mb-6">Cumulative Progress</h1>
                    <div id="metrics-container" class="grid grid-cols-2 md:grid-cols-3 gap-4 sm:gap-6 mb-8"></div>
                    
                    <h2 class="text-xl font-semibold text-gray-300 mt-8 mb-4 border-b border-gray-700 pb-2 flex items-center">
                        <i data-lucide="bar-chart-2" class="w-5 h-5 mr-2"></i> Weekly Focus Breakdown
                    </h2>
                    <canvas id="weeklyChart" class="max-h-64"></canvas>
                    
                    <h2 class="text-xl font-semibold text-gray-300 mt-8 mb-4 border-b border-gray-700 pb-2 flex items-center">
                        <i data-lucide="pie-chart" class="w-5 h-5 mr-2"></i> Subject Distribution
                    </h2>
                    <canvas id="subjectChart" class="max-h-64"></canvas>
                </div>
            </div>

            <div id="settings-view" class="hidden">
                <div class="glass-base p-6 rounded-3xl shadow-2xl mb-8 bg-gray-800/30 border-gray-500/50">
                    <h1 class="text-2xl font-bold text-yellow-300 mb-6">Application Settings</h1>
                    
                    <div class="mb-8">
                        <h2 class="text-xl font-semibold text-gray-300 mb-4 border-b border-gray-700 pb-2 flex items-center">
                            <i data-lucide="award" class="w-5 h-5 mr-2"></i> Daily Streak Goal
                        </h2>
                        <div class="flex flex-col sm:flex-row sm:items-center space-y-3 sm:space-y-0 sm:space-x-4">
                            <label for="daily-goal-input" class="text-gray-400 font-medium flex-shrink-0">Daily Focus Goal (Minutes):</label>
                            <input id="daily-goal-input" type="number" min="5" value="30" class="w-full sm:w-24 p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-yellow-500 focus:border-yellow-500 focus:outline-none text-center" onchange="updateDailyGoal(this.value)">
                        </div>
                        <p class="text-sm text-gray-500 mt-2">Set the minimum focus time required to keep your daily streak alive.</p>
                    </div>
                    
                    <div class="mb-8">
                        <h2 class="text-xl font-semibold text-gray-300 mb-4 border-b border-gray-700 pb-2 flex items-center">
                            <i data-lucide="book-open-check" class="w-5 h-5 mr-2"></i> Subject Management
                        </h2>
                        <div class="mb-6 flex space-x-3">
                            <div class="flex items-center bg-white/10 rounded-full p-3 flex-grow">
                                <i data-lucide="book-open" class="w-5 h-5 mr-3 text-yellow-400 flex-shrink-0"></i>
                                <input id="new-subject-input" type="text" maxlength="30" placeholder="Enter new subject name" class="w-full bg-transparent text-white placeholder-gray-400 focus:outline-none" onkeypress="if(event.key === 'Enter') addSubjectHandler()">
                            </div>
                            <button onclick="addSubjectHandler()" class="p-3 rounded-full bg-yellow-600 hover:bg-yellow-700 transition-colors flex-shrink-0">
                                <i data-lucide="plus" class="w-6 h-6"></i>
                            </button>
                        </div>
                        <div id="subjects-list-manager" class="space-y-3 max-h-96 overflow-y-auto pt-2"></div>
                    </div>
                    
                    <div class="mb-8">
                        <h2 class="text-xl font-semibold text-gray-300 mb-4 border-b border-gray-700 pb-2 flex items-center">
                            <i data-lucide="database" class="w-5 h-5 mr-2"></i> Data Management
                        </h2>
                        <div class="space-y-3">
                            <button onclick="exportData()" class="w-full p-3 rounded-lg bg-indigo-600 hover:bg-indigo-700 transition-colors flex items-center justify-center">
                                <i data-lucide="download" class="w-5 h-5 mr-2"></i>
                                Export All Data (JSON)
                            </button>
                            <button onclick="exportCsvData()" class="w-full p-3 rounded-lg bg-emerald-600 hover:bg-emerald-700 transition-colors flex items-center justify-center">
                                <i data-lucide="file-text" class="w-5 h-5 mr-2"></i>
                                Export Sessions (CSV)
                            </button>
                            <button onclick="document.getElementById('import-file').click()" class="w-full p-3 rounded-lg bg-emerald-600 hover:bg-emerald-700 transition-colors flex items-center justify-center">
                                <i data-lucide="upload" class="w-5 h-5 mr-2"></i>
                                Import Data (JSON)
                            </button>
                            <input type="file" id="import-file" accept=".json" class="hidden" onchange="importData(event)">
                            <button onclick="clearAllData()" class="w-full p-3 rounded-lg bg-red-600 hover:bg-red-700 transition-colors flex items-center justify-center">
                                <i data-lucide="trash-2" class="w-5 h-5 mr-2"></i>
                                Clear All Data
                            </button>
                        </div>
                    </div>
                    
                    <div class="mb-8">
                        <h2 class="text-xl font-semibold text-gray-300 mb-4 border-b border-gray-700 pb-2 flex items-center">
                            <i data-lucide="keyboard" class="w-5 h-5 mr-2"></i> Keyboard Shortcuts
                        </h2>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between p-2 bg-gray-800/50 rounded">
                                <span class="text-gray-400">Start Timer (only)</span>
                                <kbd class="px-2 py-1 bg-gray-700 rounded">Space</kbd>
                            </div>
                            <div class="flex justify-between p-2 bg-gray-800/50 rounded">
                                <span class="text-gray-400">Stop Session</span>
                                <kbd class="px-2 py-1 bg-gray-700 rounded">S</kbd>
                            </div>
                            <div class="flex justify-between p-2 bg-gray-800/50 rounded">
                                <span class="text-gray-400">Discard Session</span>
                                <kbd class="px-2 py-1 bg-gray-700 rounded">D</kbd>
                            </div>
                            <div class="flex justify-between p-2 bg-gray-800/50 rounded">
                                <span class="text-gray-400">Toggle Fullscreen</span>
                                <kbd class="px-2 py-1 bg-gray-700 rounded">F</kbd>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div id="details-modal" class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-40 p-4" onclick="if(event.target === this) closeModal()">
        <div class="w-full max-w-md bg-gray-900 border border-indigo-600/50 rounded-xl p-6 shadow-2xl">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-indigo-400 flex items-center">
                    <i data-lucide="file-text" class="w-5 h-5 mr-2"></i>
                    Session Details
                </h3>
                <button onclick="deleteSession(currentSessionId)" class="p-2 rounded-full text-red-400 hover:bg-white/10 transition-colors">
                    <i data-lucide="trash-2" class="w-5 h-5"></i>
                </button>
            </div>
            <div id="modal-content" class="text-gray-300 whitespace-pre-wrap mb-4"></div>
            <div class="flex space-x-3">
                <button onclick="closeModal()" class="flex-1 p-3 rounded-full font-semibold transition-colors bg-gray-700 hover:bg-gray-600">
                    Close
                </button>
            </div>
        </div>
    </div>
    
    <div id="fullscreen-clock-modal" class="hidden fixed inset-0 bg-black/95 z-50 flex flex-col items-center justify-center p-4">
        <button onclick="toggleFullscreenClock()" class="absolute top-6 right-6 p-3 rounded-full text-white bg-white/10 hover:bg-white/20 transition-colors z-50">
            <i data-lucide="minimize" class="w-8 h-8"></i>
        </button>
        <div class="text-center">
            <p id="fullscreen-time-display" class="text-white text-[12rem] lg:text-[18rem] xl:text-[25rem] font-extrabold tabular-nums tracking-tighter">00:00:00</p>
            <p id="fullscreen-subject-goal" class="text-4xl font-semibold text-indigo-400 mt-4"></p>
        </div>
    </div>
    
    <audio id="music-player" preload="auto"></audio>
    <div id="toast-container"></div>

    <script>
        const LOCAL_STORAGE_KEY = 'studyTrackerProData';
        const CIRCLE_CIRCUMFERENCE = 2 * Math.PI * 30;
        
        // NEW: Timer Presets Configuration
        const PRESETS = {
            'free': { focus: Infinity, break: 0, name: 'Free Mode', icon: 'sun', color: 'indigo' },
            '25/5': { focus: 25 * 60, break: 5 * 60, name: '25/5 Pomodoro', icon: 'timer', color: 'emerald' },
            '50/10': { focus: 50 * 60, break: 10 * 60, name: '50/10 Focus', icon: 'clock', color: 'yellow' }
        };
        
        const SUBJECT_COLORS = ['indigo', 'emerald', 'sky', 'yellow', 'red', 'purple', 'teal', 'pink'];
        const DEFAULT_SUBJECTS = [
            { id: 'physics', name: 'Physics', color: 'indigo' },
            { id: 'chemistry', name: 'Chemistry', color: 'emerald' },
            { id: 'math', name: 'Math', color: 'sky' },
            { id: 'other', name: 'Other', color: 'yellow' },
            { id: 'lang', name: 'Language', color: 'red' },
        ];
        
        const ACHIEVEMENTS_CONFIG = [
            { id: 'focused_hour_easy', icon: 'hourglass', name: 'First Step (1h)', unit: 'minutes', description: 'Log one hour of focused time.', goal: 60, color: 'text-amber-300' },
            { id: 'focused_hour_medium', icon: 'hourglass', name: 'Time Manager (5h)', unit: 'minutes', description: 'Log five hours of focused time.', goal: 300, color: 'text-gray-300' },
            { id: 'focused_hour_hard', icon: 'hourglass', name: 'Flow State Master (20h)', unit: 'minutes', description: 'Log twenty hours of focused time.', goal: 1200, color: 'text-indigo-400' },
            { id: 'tasks_done_easy', icon: 'check-circle', name: 'Getting Things Done (5)', unit: 'tasks', description: 'Complete 5 tasks.', goal: 5, color: 'text-amber-300' },
            { id: 'tasks_done_medium', icon: 'check-circle', name: 'Productivity Pro (20)', unit: 'tasks', description: 'Complete 20 tasks.', goal: 20, color: 'text-gray-300' },
            { id: 'tasks_done_hard', icon: 'check-circle', name: 'Executioner (50)', unit: 'tasks', description: 'Complete 50 tasks.', goal: 50, color: 'text-indigo-400' }
        ];

        const DEFAULT_STATE = {
            isRunning: false,
            timeElapsed: 0,
            startTime: null,
            subjects: DEFAULT_SUBJECTS,
            currentSubject: DEFAULT_SUBJECTS[0].id,
            sessionGoal: '',
            sessions: [],
            tasks: [],
            currentPage: 'timer',
            totalFocusTime: 0,
            isPomodoroActive: false,
            pomodoroMode: 'focus',
            pomodoroTimeRemaining: 0, // Will be initialized by setTimerMode on load
            currentDailyStreak: 0,
            lastActiveDate: null,
            dailyFocusGoalMinutes: 30,
            dailyTimeLogged: 0,
            unlockedAchievements: [],
            longestDailyStreak: 0,
            timerMode: 'free', // NEW: Default mode is 'free'
        };

        let state = { ...DEFAULT_STATE };
        let intervalId = null;
        let currentSongIndex = 0;
        let currentSessionId = null;
        let weeklyChart = null;
        let subjectChart = null;
        
        const PLAYLIST = [
            'assets/song1.mp3',
            'assets/song2.mp3',
            'assets/song3.mp3',
            'assets/song4.mp3',
            'assets/song5.mp3',
        ];
        
        let stats = {
            overallTime: 0,
            monthlyTime: 0,
            weeklyTime: 0,
            prevMonthlyTime: 0,
            prevWeeklyTime: 0,
            dailyTimeInWeek: Array(7).fill(0),
            tasksCompleted: 0,
            totalTasks: 0,
            efficiency: 0,
            avgDailyHours: 0,
            avgSessionLengthSeconds: 0,
            achievements: {},
            subjectBreakdown: {},
            mostFocusedSubject: 'N/A',
            mostFocusedSubjectRatio: 0,
        };

        const D = {
            timerTitle: document.getElementById('timer-title'),
            timeDisplay: document.getElementById('time-display'),
            taskInput: document.getElementById('task-input'),
            startPauseBtn: document.getElementById('start-pause-btn'),
            stopBtn: document.getElementById('stop-btn'),
            discardBtn: document.getElementById('discard-btn'),
            musicBtn: document.getElementById('music-btn'),
            musicPlayer: document.getElementById('music-player'),
            // NEW: Preset Buttons
            presetFreeBtn: document.getElementById('preset-free-btn'),
            preset255Btn: document.getElementById('preset-25-5-btn'),
            preset5010Btn: document.getElementById('preset-50-10-btn'),
            // End NEW
            historyList: document.getElementById('history-list'),
            noHistory: document.getElementById('no-history'),
            subjectSelector: document.getElementById('subject-selector'),
            detailsModal: document.getElementById('details-modal'),
            modalContent: document.getElementById('modal-content'),
            streakProgressBar: document.getElementById('streak-progress-bar'),
            streakProgressPercent: document.getElementById('streak-progress-percent'),
            streakCount: document.getElementById('streak-count'),
            nextStreakInfo: document.getElementById('next-streak-info'),
            timerView: document.getElementById('timer-view'),
            tasksView: document.getElementById('tasks-view'),
            historyView: document.getElementById('history-view'),
            achievementsView: document.getElementById('achievements-view'),
            progressView: document.getElementById('progress-view'),
            settingsView: document.getElementById('settings-view'),
            navTimerBtn: document.getElementById('nav-timer-btn'),
            navTasksBtn: document.getElementById('nav-tasks-btn'),
            navHistoryBtn: document.getElementById('nav-history-btn'),
            navAchievementsBtn: document.getElementById('nav-achievements-btn'),
            navProgressBtn: document.getElementById('nav-progress-btn'),
            navSettingsBtn: document.getElementById('nav-settings-btn'),
            taskInputNew: document.getElementById('new-task-input'),
            taskPriority: document.getElementById('task-priority'),
            taskDueDate: document.getElementById('task-due-date'),
            tasksListContainer: document.getElementById('tasks-list'),
            noTasks: document.getElementById('no-tasks'),
            dateSelector: document.getElementById('date-selector'),
            historySearch: document.getElementById('history-search'),
            dailySummaryContainer: document.getElementById('daily-summary-container'),
            trophiesContainer: document.getElementById('trophies-container'),
            metricsContainer: document.getElementById('metrics-container'),
            weeklyChart: document.getElementById('weeklyChart'),
            subjectChart: document.getElementById('subjectChart'),
            fullscreenClockModal: document.getElementById('fullscreen-clock-modal'),
            fullscreenTimeDisplay: document.getElementById('fullscreen-time-display'),
            fullscreenSubjectGoal: document.getElementById('fullscreen-subject-goal'),
            fullscreenBtn: document.getElementById('fullscreen-btn'),
            newSubjectInput: document.getElementById('new-subject-input'),
            subjectsListManager: document.getElementById('subjects-list-manager'),
            dailyGoalInput: document.getElementById('daily-goal-input'),
            toastContainer: document.getElementById('toast-container'),
        };

        // UTILITIES
        function formatTime(totalSeconds, includeHours) {
            const totalSec = Math.max(0, Math.floor(totalSeconds));
            const hours = Math.floor(totalSec / 3600);
            const minutes = Math.floor((totalSec % 3600) / 60);
            const seconds = Math.floor(totalSec % 60);
            const minutesStr = minutes.toString().padStart(2, '0');
            const secondsStr = seconds.toString().padStart(2, '0');
            if (includeHours || hours > 0) {
                const hoursStr = hours.toString().padStart(2, '0');
                return `${hoursStr}:${minutesStr}:${secondsStr}`;
            }
            return `${minutesStr}:${secondsStr}`;
        }

        const formatMinutes = (seconds) => {
            const totalMinutes = Math.floor(seconds / 60);
            if (totalMinutes < 60) return `${totalMinutes} min`;
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            return `${hours}h ${minutes}m`;
        };

        function formatComparison(current, previous, unit) {
            if (previous === 0) return `<span class="text-gray-400">No previous ${unit} data</span>`;

            const change = current - previous;
            const percentChange = (change / previous) * 100;
            const formattedPercent = Math.abs(percentChange).toFixed(0);

            if (Math.abs(percentChange) < 1) return `<span class="text-gray-400">Same as last ${unit}</span>`;

            let icon = 'minus', color = 'text-gray-400', direction = 'No change';
            if (percentChange > 0) {
                icon = 'arrow-up-right';
                color = 'text-emerald-400';
                direction = 'Up';
            } else if (percentChange < 0) {
                icon = 'arrow-down-right';
                color = 'text-red-400';
                direction = 'Down';
            }

            return `<span class="${color} flex items-center"><i data-lucide="${icon}" class="w-4 h-4 mr-1"></i>${direction} ${formattedPercent}%</span>`;
        }

        function getFormattedDate(isoString) {
            if (!isoString) return null;
            return isoString.split('T')[0];
        }
        
        function formatDateForDisplay(dateKey) {
            const date = new Date(dateKey + 'T00:00:00');
            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric', timeZone: 'UTC' });
        }

        function getPeriodStart(period, referenceDate = new Date()) {
            const date = new Date(referenceDate.getTime());
            date.setHours(0, 0, 0, 0);

            if (period === 'week') {
                const day = date.getDay() || 7; // Monday is 1, Sunday is 0/7
                date.setDate(date.getDate() - day + 1);
                return date;
            } else if (period === 'prevWeek') {
                const startOfWeek = getPeriodStart('week', referenceDate);
                startOfWeek.setDate(startOfWeek.getDate() - 7);
                return startOfWeek;
            } else if (period === 'month') {
                date.setDate(1);
                return date;
            } else if (period === 'prevMonth') {
                date.setDate(1);
                date.setMonth(date.getMonth() - 1);
                return date;
            }

            return new Date(0); // Epoch
        }

        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = 'toast';
            if (type === 'error') toast.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
            toast.innerHTML = `<div class="flex items-center"><i data-lucide="${type === 'success' ? 'check-circle' : 'alert-triangle'}" class="w-5 h-5 mr-2"></i>${message}</div>`;
            D.toastContainer.appendChild(toast);
            window.createLucideIcons();
            setTimeout(() => toast.remove(), 3000);
        }

        // STORAGE
        function loadState() {
            try {
                const storedState = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (storedState) {
                    const loadedState = JSON.parse(storedState);
                    state = { ...DEFAULT_STATE, ...loadedState };

                    // Handle time difference if timer was running when closed
                    if (state.isRunning && state.startTime) {
                        const timeSinceStart = (Date.now() - state.startTime) / 1000;
                        if (state.isPomodoroActive) {
                            state.pomodoroTimeRemaining = Math.max(0, state.pomodoroTimeRemaining - timeSinceStart);
                        } else {
                            state.timeElapsed += timeSinceStart;
                        }
                    }
                }
            } catch (error) {
                console.error("Error loading state:", error);
                state = { ...DEFAULT_STATE };
            }

            // Ensure timerMode is set for legacy states and initialize pomodoroTimeRemaining
            if (!state.timerMode || !PRESETS[state.timerMode]) {
                state.timerMode = 'free';
            }
            if (state.pomodoroTimeRemaining === 0) {
                // Set initial time to the focus time of the selected mode (or free if not active)
                state.pomodoroTimeRemaining = state.isPomodoroActive ? (state.pomodoroMode === 'focus' ? PRESETS[state.timerMode].focus : PRESETS[state.timerMode].break) : PRESETS['free'].focus;
            }
            
            // Streak check and reset
            const now = new Date();
            const todayKey = getFormattedDate(now.toISOString());
            const lastActiveKey = state.lastActiveDate ? getFormattedDate(state.lastActiveDate) : null;

            if (lastActiveKey && lastActiveKey !== todayKey) {
                const yesterday = new Date(now.getTime());
                yesterday.setDate(now.getDate() - 1);
                const yesterdayKey = getFormattedDate(yesterday.toISOString());
                
                // Check if yesterday's goal was met
                const goalMetYesterday = state.sessions.filter(s => getFormattedDate(s.timestamp) === lastActiveKey)
                    .reduce((total, s) => total + s.duration, 0) >= (state.dailyFocusGoalMinutes * 60);

                // If last active was not yesterday, or if it was yesterday but goal wasn't met, reset the streak
                if (lastActiveKey !== yesterdayKey || !goalMetYesterday) {
                    // Check if goal met today, to prevent streak reset on first load of the day
                    const goalMetToday = state.sessions.filter(s => getFormattedDate(s.timestamp) === todayKey)
                        .reduce((total, s) => total + s.duration, 0) >= (state.dailyFocusGoalMinutes * 60);
                        
                    if(!goalMetToday) {
                        state.currentDailyStreak = 0;
                        state.dailyTimeLogged = 0;
                    } else {
                        // If it's a new day and goal met today, but yesterday was missed, reset dailyTimeLogged
                        state.dailyTimeLogged = state.sessions.filter(s => getFormattedDate(s.timestamp) === todayKey)
                            .reduce((total, s) => total + s.duration, 0);
                    }
                } else if (lastActiveKey === yesterdayKey && goalMetYesterday) {
                    // It is a new day (todayKey !== lastActiveKey) and goal met yesterday, so log today's time and potentially increment streak later
                    state.dailyTimeLogged = state.sessions.filter(s => getFormattedDate(s.timestamp) === todayKey)
                        .reduce((total, s) => total + s.duration, 0);
                }
            } else if (lastActiveKey === todayKey) {
                // Still on the same day, update dailyTimeLogged
                state.dailyTimeLogged = state.sessions.filter(s => getFormattedDate(s.timestamp) === todayKey)
                    .reduce((total, s) => total + s.duration, 0);
            }

            state.lastActiveDate = now.toISOString();
            saveState();
            calculateStats();
        }

        function saveState() {
            try {
                // Ensure state.isRunning is false before saving if a pomodoro ended or free timer wasn't manually started
                if (state.timerMode !== 'free' && state.isPomodoroActive && state.pomodoroTimeRemaining <= 0) {
                    state.isRunning = false;
                    state.startTime = null;
                    if (intervalId) {
                        clearInterval(intervalId);
                        intervalId = null;
                    }
                }

                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));
            } catch (error) {
                console.error("Error saving state:", error);
                showToast('Failed to save data to local storage.', 'error');
            }
        }

      // TIMER LOGIC
function setTimerMode(mode) {
    if (state.isRunning) {
        showToast('Stop or pause the current session before changing the timer mode.', 'error');
        return;
    }
    
    state.timerMode = mode;
    state.isPomodoroActive = (mode !== 'free');
    
    // Reset state for new mode
    state.pomodoroMode = 'focus';
    state.pomodoroTimeRemaining = PRESETS[mode].focus;
    state.timeElapsed = 0;
    
    // --- FIX: Initialize Background Timing State ---
    
    // Clear any previous timing context
    state.pauseTime = 0; 
    state.wasPaused = false;
    
    if (state.isPomodoroActive) {
        // When setting a Pomodoro/Break mode, we initialize the startTime
        // as if the timer had just started 'now' with 0 elapsed time.
        // This is necessary because the tick() function now relies on startTime.
        state.startTime = Date.now();
    } else {
        // For Free Mode, we want the count-up to start from when the user presses 'Start'
        // but we still clear the previous startTime context.
        state.startTime = 0; // Will be set to Date.now() when startPauseHandler is called
    }
    
    // ---------------------------------------------
    
    // UI updates
    updateUI();
    
    // --- FIX: Update Preset button styles and ensure color is applied ---
    const btns = [D.presetFreeBtn, D.preset255Btn, D.preset5010Btn];
    
    btns.forEach(btn => {
        let btnMode = btn.id.replace('preset-', '').replace('-btn', '');
        
        // **CRITICAL FIX:** Normalize the btnMode string to match the 'mode' variable (e.g., '25-5' -> '25/5')
        btnMode = btnMode.replace(/-/g, '/'); 
        
        if (btnMode === mode) {
            // Apply active styles (Indigo color)
            btn.classList.add('bg-indigo-600/70', 'hover:bg-indigo-600');
            btn.classList.remove('bg-gray-700/50', 'hover:bg-gray-600/70');
            btn.classList.add('text-white'); 
        } else {
            // Apply inactive styles (Gray color)
            btn.classList.remove('bg-indigo-600/70', 'hover:bg-indigo-600', 'text-white');
            btn.classList.add('bg-gray-700/50', 'hover:bg-gray-600/70');
        }
    });
    saveState();
}

        function startPauseHandler() {
    if (state.isPomodoroActive && state.pomodoroTimeRemaining <= 0) {
        // Pomodoro ended, do not start/pause, wait for stopSession or next phase
        return;
    }

    if (state.isRunning) {
        // --- PAUSE LOGIC ---
        state.isRunning = false;
        if (intervalId) {
            clearInterval(intervalId);
            intervalId = null;
        }
        
        // FIX: Track the exact system time when paused
        state.pauseTime = Date.now(); 
        state.wasPaused = true; // Assuming you have this state property

    } else {
        // --- START/RESUME LOGIC ---
        state.isRunning = true;

        // If resuming (wasPaused is true):
        if (state.wasPaused) {
            const timeElapsedDuringPause = Date.now() - state.pauseTime;
            // Shift the original startTime forward by the length of the pause
            state.startTime += timeElapsedDuringPause; 
            state.wasPaused = false;
        } 
        // If starting a brand new session:
        else if (state.timeElapsed === 0 && !state.isPomodoroActive) {
            // Set the start time. This is only reliable for Free Mode (timeElapsed=0).
            state.startTime = Date.now();
        }

        intervalId = setInterval(tick, 1000);
        
        // Removed the 'Initialize a new session' logic as it's cleaner to handle 
        // the initial setup elsewhere or assume state is ready here.
    }
    
    updateUI();
    saveState();
}

        function tick() {
            if (!state.isRunning) return;

            // Free Mode
            if (!state.isPomodoroActive) {
                state.timeElapsed++;
                state.totalFocusTime++;
                state.dailyTimeLogged++;
            } 
            // Pomodoro Mode
            else {
                state.pomodoroTimeRemaining--;

                if (state.pomodoroMode === 'focus') {
                    state.timeElapsed++;
                    state.totalFocusTime++;
                    state.dailyTimeLogged++;
                }

                if (state.pomodoroTimeRemaining <= 0) {
                    // Auto-pause and handle phase transition
                    state.isRunning = false;
                    clearInterval(intervalId);
                    intervalId = null;
                    state.startTime = null;

                    if (state.pomodoroMode === 'focus') {
                        // End Focus, start break
                        const focusDuration = PRESETS[state.timerMode].focus;
                        // Log the completed focus session
                        logSession(focusDuration); 

                        // Check if a break is needed (50/10 mode has a break)
                        if (PRESETS[state.timerMode].break > 0) {
                            state.pomodoroMode = 'break';
                            state.pomodoroTimeRemaining = PRESETS[state.timerMode].break;
                            showToast(`Focus complete! Time for a ${formatMinutes(state.pomodoroTimeRemaining)} break.`, 'success');
                        } else {
                             // No break, simply stop (e.g., if using a custom Pomodoro mode without a break)
                            state.isPomodoroActive = false;
                            setTimerMode('free'); // Revert to free mode
                            showToast(`Focus complete! Session logged.`, 'success');
                        }

                    } else if (state.pomodoroMode === 'break') {
                        // End Break, go back to Focus
                        state.pomodoroMode = 'focus';
                        state.pomodoroTimeRemaining = PRESETS[state.timerMode].focus;
                        showToast(`Break over! Time to focus again.`, 'success');
                    }
                }
            }

            updateUI();
            saveState();
        }
        
        function logSession(durationOverride = state.timeElapsed) {
            const now = new Date();
            const session = {
                id: Date.now().toString(),
                timestamp: now.toISOString(),
                duration: durationOverride, // Use timeElapsed for free mode, or focus time for pomodoro
                subjectId: state.currentSubject,
                goal: D.taskInput.value.trim() || 'No goal set',
                mode: state.isPomodoroActive ? `${state.timerMode} (${state.pomodoroMode})` : 'Free Mode',
            };

            // Only log if duration is more than 5 seconds (to prevent logging accidental clicks)
            if (session.duration > 5) {
                state.sessions.unshift(session);
                showToast(`Session logged: ${formatMinutes(session.duration)} of focused time!`, 'success');

                // Update tasks: create an associated completed task
                if (D.taskInput.value.trim()) {
                    const task = {
                        id: 's' + session.id,
                        text: `[Focus Session] ${D.taskInput.value.trim()} (${formatMinutes(session.duration)})`,
                        completed: true,
                        priority: 'low',
                        dueDate: now.toISOString().split('T')[0],
                        completionDate: now.toISOString(),
                    };
                    state.tasks.unshift(task);
                }
            }
            
            // Recalculate stats for achievement and streak checks
            calculateStats();
            checkAchievements();
            checkDailyStreak();
            
            // Reset for a new session
            state.timeElapsed = 0;
            D.taskInput.value = '';
            
            saveState();
            renderHistory();
        }

        function stopSession() {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            state.isRunning = false;
            state.startTime = null;

            logSession(state.isPomodoroActive ? PRESETS[state.timerMode].focus : state.timeElapsed);

            // Pomodoro mode specific reset: ensure pomodoroTimeRemaining is reset to focus time of current mode
            if (state.isPomodoroActive) {
                state.pomodoroMode = 'focus';
                state.pomodoroTimeRemaining = PRESETS[state.timerMode].focus;
            } else {
                state.pomodoroTimeRemaining = PRESETS['free'].focus;
            }

            updateUI();
        }

        function discardSession() {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            state.isRunning = false;
            state.startTime = null;
            state.timeElapsed = 0;
            D.taskInput.value = '';

            // Pomodoro mode specific reset
            if (state.isPomodoroActive) {
                state.pomodoroMode = 'focus';
                state.pomodoroTimeRemaining = PRESETS[state.timerMode].focus;
            } else {
                state.pomodoroTimeRemaining = PRESETS['free'].focus;
            }
            
            showToast('Session discarded.', 'error');
            updateUI();
            saveState();
        }
        function filterExpiredTasks() {
    // Get today's date as a string (YYYY-MM-DD) for accurate comparison
    const today = new Date().toISOString().split('T')[0]; 
    let tasksChanged = false;

    // Filter the state.tasks array
    const activeTasks = state.tasks.filter(task => {
        
        // 1. Completed tasks are always kept (for history/metrics).
        if (task.completed) {
            return true;
        }

        // 2. Tasks without a dueDate are kept (they have no deadline).
        if (!task.dueDate) {
            return true;
        }

        // 3. If the dueDate is today or in the future, we keep it.
        // String comparison works correctly for YYYY-MM-DD format.
        if (task.dueDate >= today) {
            return true; // Keep the task
        }

        // 4. If none of the above, the task is UNCOMPLETED and PAST DUE.
        tasksChanged = true;
        return false; // Remove the expired task
    });

    // Only update and save state if tasks were actually removed
    if (tasksChanged) {
        state.tasks = activeTasks;
        saveState();
        showToast('Expired tasks have been automatically cleared from the list. âœ…', 'info');
    }
}
        // UI UPDATES
        function updateUI() {
            const timeToDisplay = state.isPomodoroActive ? state.pomodoroTimeRemaining : state.timeElapsed;
            D.timeDisplay.textContent = formatTime(timeToDisplay, true);
            D.fullscreenTimeDisplay.textContent = formatTime(timeToDisplay, true);

            // Pomodoro Title Update
            if (state.isPomodoroActive) {
                const currentMode = PRESETS[state.timerMode];
                const modeText = state.pomodoroMode === 'focus' ? 'Focus Time' : 'Break Time';
                D.timerTitle.innerHTML = `<i data-lucide="${currentMode.icon}" class="w-6 h-6 inline mr-2 text-${currentMode.color}-400"></i> ${currentMode.name}: ${modeText}`;
            } else {
                D.timerTitle.textContent = 'Focused Subject Tracker';
            }
            window.createLucideIcons(); // Update icons in title

            // Stop/Discard Button states
            if (state.isPomodoroActive) {
                D.stopBtn.disabled = !state.isRunning || state.pomodoroMode === 'break';
                D.discardBtn.disabled = !state.isRunning || state.pomodoroMode === 'break';
            } else {
                const hasTimeElapsed = state.timeElapsed > 0;
                D.stopBtn.disabled = !state.isRunning && !hasTimeElapsed;
                D.discardBtn.disabled = !state.isRunning && !hasTimeElapsed;
            }

            // === FIX: Robust Play/Pause Button Icon Update (Handles Lucide Icon replacement) ===
            const btn = D.startPauseBtn;
            let iconName = state.isRunning ? 'pause' : 'play';

            // 1. Update button color classes
            if (state.isRunning) {
                btn.classList.remove('bg-green-500', 'hover:bg-green-600');
                btn.classList.add('bg-indigo-500', 'hover:bg-indigo-600');
            } else {
                btn.classList.remove('bg-indigo-500', 'hover:bg-indigo-600');
                btn.classList.add('bg-green-500', 'hover:bg-green-600');
            }

            // 2. Remove all children (This removes the old rendered <svg> icon)
            while (btn.firstChild) {
                btn.removeChild(btn.firstChild);
            }

            // 3. Create a new <i> placeholder with the correct data-lucide attribute
            const newIcon = document.createElement('i');
            newIcon.setAttribute('data-lucide', iconName);
            newIcon.className = 'w-6 h-6'; // Re-add the necessary size classes

            // 4. Append the new icon to the button
            btn.appendChild(newIcon);

            // 5. Re-render the icon (This replaces the new <i> with the correct <svg> icon)
            window.createLucideIcons();
            // === END FIX ===
            
            // Task input state
            D.taskInput.disabled = state.isRunning;
            
            // Streak Progress Bar
            const goalSeconds = state.dailyFocusGoalMinutes * 60;
            const progress = Math.min(1, state.dailyTimeLogged / goalSeconds);
            const offset = CIRCLE_CIRCUMFERENCE * (1 - progress);
            D.streakProgressBar.style.strokeDashoffset = offset;
            D.streakProgressPercent.textContent = `${Math.floor(progress * 100)}%`;
            D.streakCount.textContent = state.currentDailyStreak;
            
            const remainingMinutes = Math.max(0, state.dailyFocusGoalMinutes - Math.floor(state.dailyTimeLogged / 60));
            if (remainingMinutes > 0) {
                D.nextStreakInfo.textContent = `Log ${remainingMinutes} more minutes to secure your streak!`;
                D.nextStreakInfo.classList.remove('text-emerald-400');
                D.nextStreakInfo.classList.add('text-gray-500');
            } else {
                D.nextStreakInfo.textContent = `Daily goal complete! Keep the streak alive!`;
                D.nextStreakInfo.classList.add('text-emerald-400');
                D.nextStreakInfo.classList.remove('text-gray-500');
            }

            // Fullscreen clock info
            const currentSubject = state.subjects.find(s => s.id === state.currentSubject);
            D.fullscreenSubjectGoal.textContent = `${currentSubject ? currentSubject.name : 'Subject'} | ${D.taskInput.value.trim() || 'No Goal'}`;
            renderHistory('', '', 5);
            window.createLucideIcons();
        }

        // SUBJECTS
        function renderSubjectSelector() {
            D.subjectSelector.innerHTML = state.subjects.map(subject => {
                const isChecked = subject.id === state.currentSubject;
                const activeClasses = isChecked ? `bg-${subject.color}-600 border-${subject.color}-400 text-white shadow-lg shadow-${subject.color}-600/50` : `bg-gray-700/50 border-gray-600 text-gray-300 hover:bg-gray-600/70`;

                return `
                    <input type="radio" id="subject-${subject.id}" name="subject-select" value="${subject.id}" class="hidden subject-radio" ${isChecked ? 'checked' : ''} onclick="selectSubject('${subject.id}')">
                    <label for="subject-${subject.id}" class="p-2 px-4 rounded-full text-sm font-medium border cursor-pointer transition-all duration-200 transform hover:scale-[1.02] ${activeClasses}">
                        ${subject.name}
                    </label>
                `;
            }).join('');
        }

        function selectSubject(subjectId) {
            state.currentSubject = subjectId;
            saveState();
            updateUI(); // Needed to potentially update the fullscreen clock info
            renderSubjectSelector();
        }

        function renderSubjectManager() {
            D.subjectsListManager.innerHTML = state.subjects.map(subject => {
                return `
                    <div class="flex justify-between items-center p-3 bg-gray-800/50 rounded-lg border border-gray-700">
                        <span class="text-gray-300 font-medium" style="color: var(--tw-color-${subject.color}-400, #a8a29e);">
                            <i data-lucide="square" class="w-4 h-4 inline mr-2 text-${subject.color}-400"></i>
                            ${subject.name}
                        </span>
                        <button onclick="removeSubject('${subject.id}')" class="p-1 rounded-full text-red-400 hover:bg-white/10 transition-colors">
                            <i data-lucide="x" class="w-4 h-4"></i>
                        </button>
                    </div>
                `;
            }).join('');
            window.createLucideIcons();
        }
        
        function addSubjectHandler() {
            const name = D.newSubjectInput.value.trim();
            if (!name) {
                showToast('Subject name cannot be empty.', 'error');
                return;
            }

            const subjectId = name.toLowerCase().replace(/\s/g, '_');
            if (state.subjects.some(s => s.id === subjectId)) {
                showToast('Subject already exists.', 'error');
                return;
            }

            // Assign next available color, cycling through the list
            const nextColorIndex = state.subjects.length % SUBJECT_COLORS.length;
            const newSubject = {
                id: subjectId,
                name: name,
                color: SUBJECT_COLORS[nextColorIndex]
            };
            
            state.subjects.push(newSubject);
            D.newSubjectInput.value = '';
            showToast(`Subject "${name}" added!`, 'success');
            saveState();
            renderSubjectSelector();
            renderSubjectManager();
        }

        function removeSubject(subjectId) {
            if (state.subjects.length <= 1) {
                showToast('Cannot remove the last subject.', 'error');
                return;
            }
            
            if (subjectId === state.currentSubject) {
                state.currentSubject = state.subjects.filter(s => s.id !== subjectId)[0].id;
            }
            
            state.subjects = state.subjects.filter(s => s.id !== subjectId);
            
            showToast('Subject removed.', 'success');
            saveState();
            renderSubjectSelector();
            renderSubjectManager();
        }
        
        // TASKS
        function renderTasks() {
            if (state.tasks.length === 0) {
                D.tasksListContainer.innerHTML = '';
                D.noTasks.classList.remove('hidden');
                return;
            }
            D.noTasks.classList.add('hidden');
            
            // Sort: Incomplete tasks first, then by priority (high > medium > low), then by due date
            const sortedTasks = [...state.tasks].sort((a, b) => {
                // 1. Completion status (incomplete first)
                if (a.completed !== b.completed) {
                    return a.completed ? 1 : -1;
                }
                
                // 2. Priority
                const priorityOrder = { high: 1, medium: 2, low: 3 };
                if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
                    return priorityOrder[a.priority] - priorityOrder[b.priority];
                }
                
                // 3. Due Date (earliest first)
                return (a.dueDate || '9999-12-31').localeCompare(b.dueDate || '9999-12-31');
            });

            D.tasksListContainer.innerHTML = sortedTasks.map(task => {
                const priorityClass = `priority-${task.priority}`;
                const completionClass = task.completed ? 'opacity-50 line-through' : 'hover:bg-gray-700/70';
                const dateDisplay = task.dueDate ? `Due: ${task.dueDate}` : 'No Due Date';
                const completionIcon = task.completed ? 'refresh-ccw' : 'check-circle';
                const completionText = task.completed ? 'Mark as Incomplete' : 'Complete Task';

                return `
                    <div id="task-${task.id}" class="flex items-start p-3 bg-gray-800/50 rounded-lg shadow-md transition-all ${priorityClass} ${completionClass}">
                        <input type="checkbox" class="mt-1 flex-shrink-0" id="checkbox-${task.id}" ${task.completed ? 'checked' : ''} onclick="toggleTaskCompletion('${task.id}')">
                        <div class="flex-grow ml-3">
                            <p class="text-sm font-medium text-gray-100">${task.text}</p>
                            <p class="text-xs text-gray-400 mt-1">${dateDisplay} | Priority: <span class="capitalize">${task.priority}</span></p>
                            ${task.completed ? `<p class="text-xs text-emerald-400 mt-1">Completed: ${formatDateForDisplay(getFormattedDate(task.completionDate))}</p>` : ''}
                        </div>
                        <button onclick="removeTask('${task.id}')" class="ml-4 p-1 rounded-full text-red-400 hover:bg-red-400/20 transition-colors flex-shrink-0" title="Delete Task">
                            <i data-lucide="trash-2" class="w-5 h-5"></i>
                        </button>
                    </div>
                `;
            }).join('');
            
            window.createLucideIcons();
        }

        function addTask() {
            const text = D.taskInputNew.value.trim();
            const priority = D.taskPriority.value;
            const dueDate = D.taskDueDate.value || null;

            if (!text) {
                showToast('Task description cannot be empty.', 'error');
                return;
            }

            const newTask = {
                id: Date.now().toString(),
                text: text,
                completed: false,
                priority: priority,
                dueDate: dueDate,
                completionDate: null,
            };

            state.tasks.unshift(newTask);
            D.taskInputNew.value = '';
            D.taskDueDate.value = '';
            
            showToast('Task added successfully!', 'success');
            saveState();
            calculateStats();
            renderTasks();
        }
        
        function toggleTaskCompletion(taskId) {
            const task = state.tasks.find(t => t.id === taskId);
            if (task) {
                task.completed = !task.completed;
                task.completionDate = task.completed ? new Date().toISOString() : null;
                
                if (task.completed) {
                    showToast('Task marked complete!', 'success');
                    checkAchievements();
                } else {
                    showToast('Task marked incomplete.', 'error');
                }
                
                saveState();
                calculateStats();
                renderTasks();
            }
        }
        
        function removeTask(taskId) {
            state.tasks = state.tasks.filter(t => t.id !== taskId);
            showToast('Task deleted.', 'error');
            saveState();
            calculateStats();
            renderTasks();
        }

        // NAVIGATION & MODALS
        function switchPage(page) {
            const views = {
                'timer': D.timerView,
                'tasks': D.tasksView,
                'history': D.historyView,
                'achievements': D.achievementsView,
                'progress': D.progressView,
                'settings': D.settingsView
            };
            
            const navButtons = {
                'timer': D.navTimerBtn,
                'tasks': D.navTasksBtn,
                'history': D.navHistoryBtn,
                'achievements': D.navAchievementsBtn,
                'progress': D.navProgressBtn,
                'settings': D.navSettingsBtn
            };

            // Hide all views
            Object.values(views).forEach(view => view.classList.add('hidden'));

            // Show selected view
            const selectedView = views[page];
            if (selectedView) {
                selectedView.classList.remove('hidden');
                state.currentPage = page;
            }
            
            // Update navigation button styles
            Object.values(navButtons).forEach(btn => {
                btn.classList.remove('bg-indigo-600');
                btn.classList.add('bg-gray-700/50', 'hover:bg-gray-700');
            });
            
            const selectedBtn = navButtons[page];
            if (selectedBtn) {
                selectedBtn.classList.remove('bg-gray-700/50', 'hover:bg-gray-700');
                selectedBtn.classList.add('bg-indigo-600');
            }
            
            // Run view-specific rendering
            if (page === 'tasks') renderTasks();
            if (page === 'history') {
                updateDateSelector();
                handleDateChange(D.dateSelector.value || '');
            }
            if (page === 'achievements') renderAchievements();
            if (page === 'progress') renderProgress();
            if (page === 'settings') renderSubjectManager();
            
            window.createLucideIcons(); // Re-render icons after DOM changes
            saveState();
        }

        function toggleFullscreenClock() {
            const isHidden = D.fullscreenClockModal.classList.contains('hidden');
            if (isHidden) {
                D.fullscreenClockModal.classList.remove('hidden');
                document.body.classList.add('modal-open');
                D.fullscreenBtn.querySelector('i').setAttribute('data-lucide', 'minimize');
            } else {
                D.fullscreenClockModal.classList.add('hidden');
                document.body.classList.remove('modal-open');
                D.fullscreenBtn.querySelector('i').setAttribute('data-lucide', 'maximize');
            }
            window.createLucideIcons();
        }
        
        function openModal(sessionId) {
            currentSessionId = sessionId;
            const session = state.sessions.find(s => s.id === sessionId);
            if (!session) return;
            
            const subject = state.subjects.find(s => s.id === session.subjectId);
            const subjectName = subject ? subject.name : 'Unknown Subject';
            const subjectColor = subject ? subject.color : 'gray';

            let content = `
                <p class="mb-2"><span class="font-bold">Subject:</span> <span class="text-${subjectColor}-300">${subjectName}</span></p>
                <p class="mb-2"><span class="font-bold">Duration:</span> ${formatTime(session.duration, true)}</p>
                <p class="mb-2"><span class="font-bold">Mode:</span> ${session.mode}</p>
                <p class="mb-2"><span class="font-bold">Date:</span> ${formatDateForDisplay(getFormattedDate(session.timestamp))}</p>
                <p class="mb-4"><span class="font-bold">Goal:</span> ${session.goal}</p>
            `;

            D.modalContent.innerHTML = content;
            D.detailsModal.classList.remove('hidden');
            document.body.classList.add('modal-open');
            window.createLucideIcons();
        }

        function closeModal() {
            D.detailsModal.classList.add('hidden');
            document.body.classList.remove('modal-open');
            currentSessionId = null;
        }

        function deleteSession(sessionId) {
            state.sessions = state.sessions.filter(s => s.id !== sessionId);
            closeModal();
            showToast('Session deleted.', 'error');
            saveState();
            calculateStats();
            renderHistory();
            handleDateChange(D.dateSelector.value || '');
            renderProgress();
        }

        // HISTORY
        function renderHistory(filterDate = '', searchTerm = '', limit = 0) {
    let filteredSessions = [...state.sessions];

    // **[NEW LOGIC START]**: Apply limit ONLY if no date or search filter is active.
    if (limit > 0 && !filterDate && !searchTerm) {
        filteredSessions = filteredSessions.slice(0, limit);
    }
    // **[NEW LOGIC END]**

    if (filterDate) {
        filteredSessions = filteredSessions.filter(s => getFormattedDate(s.timestamp) === filterDate);
    }
    
    if (searchTerm) {
        const searchLower = searchTerm.toLowerCase();
        filteredSessions = filteredSessions.filter(s => 
            s.goal.toLowerCase().includes(searchLower) ||
            s.mode.toLowerCase().includes(searchLower) ||
            (state.subjects.find(sub => sub.id === s.subjectId)?.name || '').toLowerCase().includes(searchLower)
        );
    }

    // Now, D.historyList must be cleared regardless of length, 
    // since this function is also called for the full History Tab.
    D.historyList.innerHTML = ''; // Ensure the container is cleared first

    if (filteredSessions.length === 0) {
        // D.historyList is already clear here
        D.noHistory.classList.remove('hidden');
        return;
    }
    
    D.noHistory.classList.add('hidden');
    
    // The rest of the rendering logic remains the same:
    D.historyList.innerHTML = filteredSessions.map(session => {
        const subject = state.subjects.find(s => s.id === session.subjectId);
        const subjectName = subject ? subject.name : 'Unknown';
        const subjectColor = subject ? subject.color : 'gray';

        return `
            <div onclick="openModal('${session.id}')" class="flex justify-between items-center p-3 bg-gray-700/50 rounded-lg cursor-pointer hover:bg-gray-700/70 transition-colors border-l-4 border-${subjectColor}-500">
                <div class="flex-grow min-w-0">
                    <p class="text-sm font-medium text-gray-300 truncate">${session.goal || 'No goal set'}</p>
                    <p class="text-xs text-gray-400">
                        <span class="capitalize text-${subjectColor}-400">${subjectName}</span> | ${session.mode}
                    </p>
                </div>
                <p class="text-lg font-bold tabular-nums text-indigo-300 ml-4 flex-shrink-0">${formatTime(session.duration, false)}</p>
            </div>
        `;
    }).join('');
    
    window.createLucideIcons();
}

        function updateDateSelector() {
            const uniqueDates = [...new Set(state.sessions.map(s => getFormattedDate(s.timestamp)))].sort().reverse();
            D.dateSelector.innerHTML = '<option value="">All Dates</option>';
            D.dateSelector.innerHTML += uniqueDates.map(date => 
                `<option value="${date}">${formatDateForDisplay(date)}</option>`
            ).join('');
            
            // Apply event listeners for search input
            D.historySearch.oninput = () => handleDateChange(D.dateSelector.value || '');
        }

      function handleDateChange(dateKey) {
    const dailySessions = state.sessions.filter(s => getFormattedDate(s.timestamp) === dateKey);
    const totalDuration = dailySessions.reduce((sum, s) => sum + s.duration, 0);
    // Renamed local variable for clarity
    const totalTasksCompletedToday = state.tasks.filter(t => getFormattedDate(t.completionDate) === dateKey).length;

    if (!dateKey) {
        // Show All Sessions view
        D.dailySummaryContainer.innerHTML = ` 
            <div class="empty-state"> 
                <div class="empty-state-icon">ðŸ“š</div> 
                <p class="text-gray-400">Viewing all sessions. Use the date selector for a daily summary.</p> 
            </div> 
        `; 
        renderHistory('', D.historySearch.value.trim());
        return;
    }
    
    // 1. Logic to get Completed and Pending Tasks for the History View
    const tasksCompletedToday = state.tasks.filter(t => getFormattedDate(t.completionDate) === dateKey).sort((a, b) => (a.completionDate || '0').localeCompare(b.completionDate || '0'));
    const activePendingTasks = state.tasks.filter(t => !t.completed).sort((a, b) => {
        // Sort pending tasks by priority (high > medium > low)
        const priorityOrder = { high: 1, medium: 2, low: 3 };
        return priorityOrder[a.priority] - priorityOrder[b.priority];
    });

    const completedTasksList = tasksCompletedToday.length > 0 ?
        tasksCompletedToday.map(t => `<li class="flex items-start text-sm text-gray-300 mb-1 line-through"><i data-lucide="check-circle" class="w-4 h-4 mr-2 mt-1 text-emerald-400 flex-shrink-0"></i><span class="truncate">${t.text}</span></li>`).join('') :
        '<li class="text-sm text-gray-500 italic">No tasks completed on this day.</li>';

    const pendingTasksList = activePendingTasks.length > 0 ?
        activePendingTasks.map(t => `<li class="flex items-start text-sm text-gray-300 mb-1"><i data-lucide="list-end" class="w-4 h-4 mr-2 mt-1 text-yellow-400 flex-shrink-0"></i><span class="truncate">${t.text}</span><span class="text-xs ml-auto text-gray-500 capitalize px-2 py-0.5 rounded-full bg-gray-800/50 flex-shrink-0">${t.priority}</span></li>`).join('') :
        '<li class="text-sm text-gray-500 italic">No active pending tasks. Excellent!</li>';
    // 2. End Task History Logic

    // Group sessions by subject for the daily summary chart (existing logic kept)
    const subjectData = dailySessions.reduce((acc, s) => {
        const subject = state.subjects.find(sub => sub.id === s.subjectId);
        const subjectName = subject ? subject.name : 'Unknown';
        if (!acc[subjectName]) {
            acc[subjectName] = 0;
        }
        acc[subjectName] += s.duration;
        return acc;
    }, {});
    
    const dailySummaryHTML = `
        <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50 mb-6">
            <h3 class="text-xl font-bold text-gray-100 mb-2">Summary for ${formatDateForDisplay(dateKey)}</h3>
            <div class="grid grid-cols-2 gap-4">
                <div class="p-3 bg-gray-800 rounded-lg">
                    <p class="text-sm text-gray-400">Total Focus Time</p>
                    <p class="text-2xl font-extrabold text-indigo-400">${formatMinutes(totalDuration)}</p>
                </div>
                <div class="p-3 bg-gray-800 rounded-lg">
                    <p class="text-sm text-gray-400">Tasks Completed</p>
                    <p class="text-2xl font-extrabold text-emerald-400">${totalTasksCompletedToday}</p>
                </div>
            </div>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div class="glass-base p-4 rounded-xl bg-gray-800/50 border-gray-700/50">
                <h3 class="text-lg font-semibold text-emerald-300 mb-3 flex items-center">
                    <i data-lucide="clipboard-check" class="w-5 h-5 mr-2"></i>
                    Tasks Completed Today (${tasksCompletedToday.length})
                </h3>
                <ul class="space-y-2 max-h-48 overflow-y-auto pr-2">
                    ${completedTasksList}
                </ul>
            </div>
            
            <div class="glass-base p-4 rounded-xl bg-gray-800/50 border-gray-700/50">
                <h3 class="text-lg font-semibold text-yellow-300 mb-3 flex items-center">
                    <i data-lucide="clipboard-list" class="w-5 h-5 mr-2"></i>
                    Active Pending Tasks (${activePendingTasks.length})
                </h3>
                <ul class="space-y-2 max-h-48 overflow-y-auto pr-2">
                    ${pendingTasksList}
                </ul>
            </div>
        </div>
        <h2 class="text-xl font-semibold text-gray-300 mt-6 mb-3 border-b border-gray-700 pb-2 flex items-center">
            <i data-lucide="list-todo" class="w-5 h-5 mr-2"></i>
            Daily Sessions
        </h2>
        <div id="daily-sessions-list" class="space-y-3"></div>
    `;

    D.dailySummaryContainer.innerHTML = dailySummaryHTML;
    
    // Rerun history render and icon creation
    renderHistory(dateKey, D.historySearch.value.trim());
    window.createLucideIcons();
}
        // STATS & PROGRESS
        function calculateStats() {
            const now = new Date();
            const startOfWeek = getPeriodStart('week', now);
            const startOfPrevWeek = getPeriodStart('prevWeek', now);
            const startOfMonth = getPeriodStart('month', now);
            const startOfPrevMonth = getPeriodStart('prevMonth', now);
            
            let overallTime = 0;
            let monthlyTime = 0;
            let weeklyTime = 0;
            let prevMonthlyTime = 0;
            let prevWeeklyTime = 0;
            let dailyTimeInWeek = Array(7).fill(0);
            let subjectBreakdown = {};
            let sessionsCount = 0;

            state.sessions.forEach(session => {
                const duration = session.duration;
                const sessionDate = new Date(session.timestamp);
                
                overallTime += duration;
                sessionsCount++;

                // Monthly/Weekly Time
                if (sessionDate >= startOfMonth) monthlyTime += duration;
                if (sessionDate >= startOfWeek) {
                    weeklyTime += duration;
                    const dayOfWeek = sessionDate.getDay(); // 0=Sun, 1=Mon...
                    const index = (dayOfWeek === 0) ? 6 : dayOfWeek - 1; // Convert to Mon=0, Sun=6
                    dailyTimeInWeek[index] += duration;
                }
                if (sessionDate >= startOfPrevMonth && sessionDate < startOfMonth) prevMonthlyTime += duration;
                if (sessionDate >= startOfPrevWeek && sessionDate < startOfWeek) prevWeeklyTime += duration;
                
                // Subject Breakdown
                const subjectName = state.subjects.find(s => s.id === session.subjectId)?.name || 'Unknown';
                subjectBreakdown[subjectName] = (subjectBreakdown[subjectName] || 0) + duration;
            });

            // Tasks Stats
            const tasksCompleted = state.tasks.filter(t => t.completed).length;
            const totalTasks = state.tasks.length;
            const efficiency = totalTasks > 0 ? Math.round((tasksCompleted / totalTasks) * 100) : 0;
            
            // Time Stats
            const totalDays = Math.ceil((Date.now() - new Date(state.sessions[state.sessions.length - 1]?.timestamp || Date.now()).getTime()) / (1000 * 3600 * 24)) || 1;
            const avgDailyHours = (overallTime / totalDays) / 3600;
            const avgSessionLengthSeconds = sessionsCount > 0 ? overallTime / sessionsCount : 0;
            
            // Most Focused Subject
            const mostFocused = Object.entries(subjectBreakdown).sort(([, a], [, b]) => b - a)[0];
            const mostFocusedSubject = mostFocused ? mostFocused[0] : 'N/A';
            const mostFocusedSubjectRatio = overallTime > 0 ? mostFocused[1] / overallTime : 0;

            stats = {
                overallTime, monthlyTime, weeklyTime, prevMonthlyTime, prevWeeklyTime, dailyTimeInWeek,
                tasksCompleted, totalTasks, efficiency, avgDailyHours, avgSessionLengthSeconds,
                subjectBreakdown, mostFocusedSubject, mostFocusedSubjectRatio
            };
        }

        function checkDailyStreak() {
            const now = new Date();
            const todayKey = getFormattedDate(now.toISOString());
            const yesterday = new Date(now.getTime());
            yesterday.setDate(now.getDate() - 1);
            const yesterdayKey = getFormattedDate(yesterday.toISOString());
            
            const lastActiveKey = state.lastActiveDate ? getFormattedDate(state.lastActiveDate) : null;
            const todayGoalMet = state.dailyTimeLogged >= (state.dailyFocusGoalMinutes * 60);

            // Check if goal met today and the streak hasn't been incremented yet
            if (todayGoalMet && lastActiveKey !== todayKey) {
                // If the last active date was yesterday AND the goal was met yesterday, increment the streak
                const goalMetYesterday = state.sessions.filter(s => getFormattedDate(s.timestamp) === yesterdayKey)
                    .reduce((total, s) => total + s.duration, 0) >= (state.dailyFocusGoalMinutes * 60);

                if (lastActiveKey === yesterdayKey && goalMetYesterday) {
                    state.currentDailyStreak++;
                    state.longestDailyStreak = Math.max(state.longestDailyStreak, state.currentDailyStreak);
                    showToast(`ðŸ”¥ Streak continued! Day ${state.currentDailyStreak}!`, 'success');
                } else if (!lastActiveKey || lastActiveKey < yesterdayKey) {
                    // Start a new streak if today is the first logged day or a missed day was logged after
                    state.currentDailyStreak = 1;
                    state.longestDailyStreak = Math.max(state.longestDailyStreak, state.currentDailyStreak);
                    showToast('ðŸ”¥ Streak started! Day 1!', 'success');
                }
            } else if (todayGoalMet && state.currentDailyStreak === 0) {
                // Special case: First day of using the app and meeting the goal
                 state.currentDailyStreak = 1;
                 state.longestDailyStreak = Math.max(state.longestDailyStreak, state.currentDailyStreak);
            }
        }

        function renderProgress() {
            // Metrics (KPIs)
            D.metricsContainer.innerHTML = `
                <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50">
                    <p class="text-sm text-gray-400">Total Focused Time</p>
                    <p class="text-2xl font-extrabold text-indigo-400">${formatMinutes(stats.overallTime)}</p>
                </div>
                <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50">
                    <p class="text-sm text-gray-400">Weekly Focus</p>
                    <p class="text-2xl font-extrabold text-indigo-400">${formatMinutes(stats.weeklyTime)}</p>
                    <p class="text-xs text-gray-500">${formatComparison(stats.weeklyTime, stats.prevWeeklyTime, 'week')}</p>
                </div>
                <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50">
                    <p class="text-sm text-gray-400">Monthly Focus</p>
                    <p class="text-2xl font-extrabold text-indigo-400">${formatMinutes(stats.monthlyTime)}</p>
                    <p class="text-xs text-gray-500">${formatComparison(stats.monthlyTime, stats.prevMonthlyTime, 'month')}</p>
                </div>
                <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50">
                    <p class="text-sm text-gray-400">Task Completion</p>
                    <p class="text-2xl font-extrabold text-emerald-400">${stats.efficiency}%</p>
                    <p class="text-xs text-gray-500">${stats.tasksCompleted} / ${stats.totalTasks} completed</p>
                </div>
                <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50">
                    <p class="text-sm text-gray-400">Longest Streak</p>
                    <p class="text-2xl font-extrabold text-red-400">${stats.longestDailyStreak || state.longestDailyStreak} days</p>
                    <p class="text-xs text-gray-500">Current: ${state.currentDailyStreak} days</p>
                </div>
                <div class="glass-base p-4 rounded-xl bg-gray-700/50 border-gray-600/50">
                    <p class="text-sm text-gray-400">Avg. Session Length</p>
                    <p class="text-2xl font-extrabold text-yellow-400">${formatMinutes(stats.avgSessionLengthSeconds)}</p>
                </div>
            `;
            
            // Weekly Focus Chart
            renderWeeklyChart(stats.dailyTimeInWeek);
            
            // Subject Distribution Chart
            renderSubjectChart(stats.subjectBreakdown);
            
            window.createLucideIcons();
        }

        function renderWeeklyChart(data) {
            const ctx = D.weeklyChart.getContext('2d');
            
            if (weeklyChart) {
                weeklyChart.destroy();
            }

            const chartData = data.map(time => time / 3600); // Convert seconds to hours

            weeklyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
                    datasets: [{
                        label: 'Hours Focused',
                        data: chartData,
                        backgroundColor: '#6366f1', // Indigo 500
                        borderRadius: 4,
                        hoverBackgroundColor: '#4f46e5', // Indigo 600
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Hours',
                                color: '#9ca3af' // Gray 400
                            },
                            grid: {
                                color: 'rgba(107, 114, 128, 0.2)' // Gray 500 with opacity
                            },
                            ticks: {
                                color: '#d1d5db' // Gray 300
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: '#d1d5db' // Gray 300
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Time: ${context.formattedValue} hours`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderSubjectChart(data) {
            const ctx = D.subjectChart.getContext('2d');
            
            if (subjectChart) {
                subjectChart.destroy();
            }

            const subjectNames = Object.keys(data);
            const subjectTimes = Object.values(data);
            
            // Generate colors that map to the state.subjects colors
            const backgroundColors = subjectNames.map(name => {
                const subject = state.subjects.find(s => s.name === name);
                const colorHex = {
                    'indigo': '#6366f1',
                    'emerald': '#34d399',
                    'sky': '#38bdf8',
                    'yellow': '#facc15',
                    'red': '#f87171',
                    'purple': '#c084fc',
                    'teal': '#2dd4bf',
                    'pink': '#f472b6',
                    'Unknown': '#6b7280'
                }[subject ? subject.color : 'Unknown'] || '#6b7280';
                return colorHex;
            });
            
            subjectChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: subjectNames,
                    datasets: [{
                        label: 'Time Focused',
                        data: subjectTimes,
                        backgroundColor: backgroundColors,
                        borderWidth: 1,
                        borderColor: '#0d1117' // Match body background for separation
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: '#d1d5db'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const value = context.parsed;
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    return `${context.label}: ${formatMinutes(value)} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // ACHIEVEMENTS
        function checkAchievements() {
            ACHIEVEMENTS_CONFIG.forEach(ach => {
                let currentProgress = 0;
                
                if (ach.unit === 'minutes') {
                    currentProgress = Math.floor(stats.overallTime / 60);
                } else if (ach.unit === 'tasks') {
                    currentProgress = stats.tasksCompleted;
                }
                
                if (currentProgress >= ach.goal && !state.unlockedAchievements.includes(ach.id)) {
                    state.unlockedAchievements.push(ach.id);
                    showToast(`ðŸ† Achievement Unlocked: ${ach.name}!`, 'success');
                }
            });
            saveState();
        }

        function renderAchievements() {
            D.trophiesContainer.innerHTML = ACHIEVEMENTS_CONFIG.map(ach => {
                const isUnlocked = state.unlockedAchievements.includes(ach.id);
                const progressValue = ach.unit === 'minutes' ? Math.floor(stats.overallTime / 60) : stats.tasksCompleted;
                const progress = Math.min(100, (progressValue / ach.goal) * 100);
                const achievedClass = isUnlocked ? 'bg-gray-800/70 border-emerald-500/50' : 'bg-gray-800/30 border-gray-700/50 opacity-70';
                const iconColor = isUnlocked ? ach.color : 'text-gray-500';

                return `
                    <div class="glass-base p-5 rounded-xl shadow-xl transition-all transform ${achievedClass} ${isUnlocked ? 'ring-2 ring-emerald-500/30' : ''}">
                        <div class="flex items-center space-x-4 mb-3">
                            <i data-lucide="${ach.icon}" class="w-8 h-8 ${iconColor} ${isUnlocked ? 'achievement-pulse' : ''}"></i>
                            <h3 class="text-xl font-bold text-gray-100">${ach.name}</h3>
                        </div>
                        <p class="text-gray-400 text-sm mb-3">${ach.description}</p>
                        <div class="w-full bg-gray-700 rounded-full h-2.5">
                            <div class="h-2.5 rounded-full transition-all duration-500 ${isUnlocked ? 'bg-emerald-500' : 'bg-indigo-500'}" style="width: ${progress}%"></div>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">${progressValue} / ${ach.goal} ${ach.unit}</p>
                    </div>
                `;
            }).join('');
            window.createLucideIcons();
        }

        // SETTINGS
        function updateDailyGoal(value) {
            const goal = parseInt(value);
            if (goal < 5) {
                state.dailyFocusGoalMinutes = 5;
                D.dailyGoalInput.value = 5;
                showToast('Minimum goal is 5 minutes.', 'error');
            } else {
                state.dailyFocusGoalMinutes = goal;
                showToast(`Daily focus goal set to ${goal} minutes.`, 'success');
            }
            saveState();
            updateUI(); // Update the streak bar immediately
        }

        // DATA MANAGEMENT
        function exportData() {
            const dataStr = JSON.stringify(state, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

            const exportFileDefaultName = 'study_tracker_data.json';

            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            showToast('Data exported successfully!', 'success');
        }

function exportCsvData() {
    let csvContent = "data:text/csv;charset=utf-8,";
    const now = new Date();
    
    // Helper to escape CSV fields
    const escapeCsv = (data) => `"${String(data || '').replace(/"/g, '""').replace(/\n/g, ' ')}"`;

    // --- SESSION HISTORY ---
    csvContent += "---SESSION_HISTORY---\n";
    const sessionHeaders = ["Date", "Duration (Minutes)", "Subject ID", "Subject Name", "Notes"].join(",");
    csvContent += sessionHeaders + "\n";

    state.sessions.sort((a, b) => a.timestamp - b.timestamp).forEach(session => {
        // Assuming getFormattedDate is available here for sessions
        const date = getFormattedDate(session.timestamp); 
        const subject = state.subjects.find(sub => sub.id === session.subjectId);
        const subjectName = subject ? subject.name : 'Unknown';
        
        const row = [
            date,
            session.duration,
            session.subjectId,
            escapeCsv(subjectName),
            escapeCsv(session.notes)
        ].join(",");
        csvContent += row + "\n";
    });

    // --- SUBJECTS LIST ---
    csvContent += "\n\n---SUBJECTS---\n";
    const subjectHeaders = ["Subject ID", "Subject Name", "Color"].join(",");
    csvContent += subjectHeaders + "\n";
    
    state.subjects.sort((a, b) => a.id - b.id).forEach(subject => {
        const row = [
            subject.id,
            escapeCsv(subject.name),
            subject.color
        ].join(",");
        csvContent += row + "\n";
    });

    // --- TASK_LIST (Completed and Pending) ---
    csvContent += "\n\n---TASK_LIST---\n";
    const taskHeaders = ["Task ID", "Task Text", "Priority", "Created Date", "Status", "Completion Date"].join(",");
    csvContent += taskHeaders + "\n";
    
    // Sort tasks by creation date
    state.tasks.sort((a, b) => (a.createdDate || '0').localeCompare(b.createdDate || '0')).forEach(task => {
        
        // FIX: Ensure date formatting is robust by replacing the dependency on getFormattedDate 
        const getTaskDateString = (dateString) => {
            if (!dateString) return 'N/A';
            try {
                // Ensure date formatting is always a simple YYYY-MM-DD string
                return new Date(dateString).toISOString().split('T')[0];
            } catch (e) {
                return 'Invalid Date';
            }
        };

        const createdDate = getTaskDateString(task.createdDate);
        const completionDate = task.completionDate ? getTaskDateString(task.completionDate) : 'Pending';
        const status = task.completed ? 'COMPLETED' : 'PENDING';

        const row = [
            `T${task.id}`,
            escapeCsv(task.text),
            task.priority || 'low',
            createdDate,
            status,
            completionDate
        ].join(",");
        csvContent += row + "\n";
    });

    // Create the download link and trigger the download
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    // FIX: Using a simple inline format for the filename date to prevent potential issues
    const fileNameDate = now.toISOString().split('T')[0].replace(/-/g, '');
    link.setAttribute("download", `study_tracker_data_${fileNameDate}.csv`);
    document.body.appendChild(link); // Required for Firefox
    link.click();
    document.body.removeChild(link);
}

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedState = JSON.parse(e.target.result);
                    
                    if (importedState.sessions && importedState.subjects && importedState.tasks) {
                        if (confirm("Are you sure you want to overwrite your current data with the imported data?")) {
                            // Simple merge/overwrite for simplicity. For a real app, merging logic is better.
                            state = { ...DEFAULT_STATE, ...importedState };
                            // Recalculate everything after a full import
                            loadState(); 
                            showToast('Data imported successfully!', 'success');
                            switchPage(state.currentPage || 'timer');
                        }
                    } else {
                        showToast('Invalid file format. Please import a valid Study Tracker JSON file.', 'error');
                    }
                } catch (error) {
                    showToast('Error reading file: Invalid JSON format.', 'error');
                }
            };
            reader.readAsText(file);
        }

        function clearAllData() {
            if (confirm("WARNING: This will permanently delete ALL your sessions, tasks, and settings. Are you absolutely sure you want to continue?")) {
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                state = { ...DEFAULT_STATE };
                // Re-initialize state to default values
                loadState(); 
                switchPage('timer');
                showToast('All application data cleared successfully.', 'success');
            }
        }

        // MUSIC PLAYER
        function initMusicPlayer() {
            D.musicPlayer.src = PLAYLIST[currentSongIndex];
            D.musicPlayer.loop = false;
            D.musicPlayer.volume = 0.5;
            D.musicPlayer.onended = () => {
                currentSongIndex = (currentSongIndex + 1) % PLAYLIST.length;
                D.musicPlayer.src = PLAYLIST[currentSongIndex];
                D.musicPlayer.play().catch(e => console.log("Playback failed (user gesture required).", e));
            };
            D.musicPlayer.ontimeupdate = updateMusicButton;
        }

        function updateMusicButton() {
            const icon = D.musicPlayer.paused ? 'music' : 'pause';
            D.musicBtn.querySelector('i').setAttribute('data-lucide', icon);
            D.musicBtn.title = D.musicPlayer.paused ? 'Play Background Music' : 'Pause Background Music';
            window.createLucideIcons();
        }

        function toggleSongPlayback() {
            if (D.musicPlayer.paused) {
                D.musicPlayer.play()
                    .then(() => showToast('Background music started.', 'success'))
                    .catch(e => showToast('Could not start music. Click anywhere on the page first.', 'error'));
            } else {
                D.musicPlayer.pause();
                showToast('Background music paused.', 'error');
            }
            updateMusicButton();
        }

    // KEYBOARD SHORTCUTS
document.addEventListener('keydown', (e) => {
    // FIX: Use a more robust check to ensure keyboard shortcuts are disabled when an editable element is focused.
    const isEditable = document.activeElement.matches('input, textarea, [contenteditable="true"]');
    
    if (!isEditable) {
        // Space: Start/Pause
        if (e.key === ' ') {
            e.preventDefault();
            startPauseHandler();
        }

        // S: Stop Session (only if timer is running or paused with time > 0)
        if (e.key.toLowerCase() === 's' && (state.isRunning || getRemainingTime() > 0)) {
            e.preventDefault();
            stopSession();
        }

        // D: Discard Session (only if paused with time > 0 or in pomodoro break)
        if (e.key.toLowerCase() === 'd' && !state.isRunning && getRemainingTime() > 0) {
            e.preventDefault();
            discardSession();
        }

        // F: Toggle Fullscreen
        if (e.key.toLowerCase() === 'f') {
            e.preventDefault();
            toggleFullscreenClock();
        }
    }
    
    // --- Global Shortcuts ---
    // Close Modal - Esc
    if (e.key === 'Escape') {
        if (!D.fullscreenClockModal.classList.contains('hidden')) {
            toggleFullscreenClock();
        } else if (!D.detailsModal.classList.contains('hidden')) {
            closeModal();
        }
    }
});

       // INITIALIZATION
        document.addEventListener('DOMContentLoaded', () => {
            loadState();
            
           
            filterExpiredTasks(); 
        
            
            initMusicPlayer();
            setTimerMode(state.timerMode); // Re-set mode on load to ensure pomodoroTimeRemaining is correct
            renderSubjectSelector();
            D.dailyGoalInput.value = state.dailyFocusGoalMinutes;
            updateUI(); // Final UI update
            
            // Re-create icons on load
            window.createLucideIcons();
            switchPage(state.currentPage || 'timer');
        });
    </script>
</body>
</html>